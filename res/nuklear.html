<html><head><meta charset="UTF-8"><meta http-equiv="content-type" content="text/html; charset=UTF-8"><style>body{max-width:680px;margin:auto;padding:20px;text-align:justify;line-height:140%; -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-smoothing:antialiased;color:#222;font-family:Palatino,Georgia,"Times New Roman",serif}</style><style>body{counter-reset: h1 h2 h3 h4 h5 h6 paragraph}@page{margin:0;size:auto}.md code,pre{font-family:Menlo,Consolas,monospace;font-size:13.141452225px;line-height:140%}.md div.title{font-size:26px;font-weight:800;line-height:120%;text-align:center}.md div.afterTitles{height:10px}.md div.subtitle{text-align:center}.md .image{display:inline-block}.md div.imagecaption,.md div.tablecaption,.md div.listingcaption{margin:5px 5px 5px 5px;text-align: justify;font-style:italic}.md div.imagecaption{margin-bottom:0}.md img{max-width:100%;page-break-inside:avoid}.md li{text-align:left}.md pre.listing {tab-size:4;-moz-tab-size:4;-o-tab-size:4}.md div.tilde{margin:20px 0 -10px;text-align:center}.md blockquote.fancyquote{margin:25px 0 25px;text-align:left;line-height:160%}.md blockquote.fancyquote::before{content:"“";color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-right:6px;vertical-align:-0.3em}.md span.fancyquote{font-size:118%;color:#777;font-style:italic}.md span.fancyquote::after{content:"”";font-style:normal;color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-left:6px;vertical-align:-0.3em}.md blockquote.fancyquote .author{width:100%;margin-top:10px;display:inline-block;text-align:right}.md small{font-size:60%}.md div.title,contents,.md .tocHeader,h1,h2,h3,h4,h5,h6,.md .shortTOC,.md .mediumTOC,.nonumberh1,.nonumberh2,.nonumberh3,.nonumberh4,.nonumberh5,.nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;margin:13.4px 0 13.4px;padding:15px 0 3px;border-top:none;clear:both}.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .nonumberh1,.md .nonumberh2,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{page-break-after:avoid;break-after:avoid}.md svg.diagram{display:block;font-family:Menlo,Consolas,monospace;font-size:13.141452225px;text-align:center;stroke-linecap:round;stroke-width:2px;page-break-inside:avoid;stroke:#000;fill:#000}.md svg.diagram .opendot{fill:#FFF}.md svg.diagram text{stroke:none}@media print{.md .pagebreak{page-break-after:always;visibility:hidden}}.md a{font-family:Georgia,Palatino,'Times New Roman'}.md h1,.md .tocHeader,.md .nonumberh1{border-bottom:3px solid;font-size:20px;font-weight:bold;}.md h1,.md .nonumberh1{counter-reset: h2 h3 h4 h5 h6}.md h2,.md .nonumberh2{counter-reset: h3 h4 h5 h6;border-bottom:2px solid #999;color:#555;font-weight:bold;font-size:18px;}.md h3,.md h4,.md h5,.md h6,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{font-family:Helvetica,Arial,sans-serif;color:#555;font-size:16px;}.md h3{counter-reset:h4 h5 h6}.md h4{counter-reset:h5 h6}.md h5{counter-reset:h6}.md div.table{margin:16px 0 16px 0}.md table{border-collapse:collapse;line-height:140%;page-break-inside:avoid}.md table.table{margin:auto}.md table.calendar{width:100%;margin:auto;font-size:11px;font-family:Helvetica,Arial,sans-serif}.md table.calendar th{font-size:16px}.md .today{background:#ECF8FA}.md .calendar .parenthesized{color:#999;font-style:italic}.md div.tablecaption{text-align:center}.md table.table th{color:#FFF;background-color:#AAA;border:1px solid #888;padding:8px 15px 8px 15px}.md table.table td{padding:5px 15px 5px 15px;border:1px solid #888}.md table.table tr:nth-child(even){background:#EEE}.md pre.tilde{border-top: 1px solid #CCC;border-bottom: 1px solid #CCC;padding: 5px 0 5px 20px;margin:0 0 0 0;background:#FCFCFC;page-break-inside:avoid}.md a.target{width:0px;height:0px;visibility:hidden;font-size:0px;display:inline-block}.md a:link, .md a:visited{color:#38A;text-decoration:none}.md a:link:hover{text-decoration:underline}.md dt{font-weight:700}.md dl>dd{margin-top:-8px; margin-bottom:8px}.md dl>table{margin:35px 0 30px}.md code{white-space:pre;page-break-inside:avoid}.md .endnote{font-size:13px;line-height:15px;padding-left:10px;text-indent:-10px}.md .bib{padding-left:80px;text-indent:-80px;text-align:left}.markdeepFooter{font-size:9px;text-align:right;padding-top:80px;color:#999}.md .mediumTOC{float:right;font-size:12px;line-height:15px;border-left:1px solid #CCC;padding-left:15px;margin:15px 0px 15px 25px}.md .mediumTOC .level1{font-weight:600}.md .longTOC .level1{font-weight:600;display:block;padding-top:12px;margin:0 0 -20px}.md .shortTOC{text-align:center;font-weight:bold;margin-top:15px;font-size:14px}.md .admonition{position:relative;margin:1em 0;padding:.4rem 1rem;border-radius:.2rem;border-left:2.5rem solid rgba(68,138,255,.4);background-color:rgba(68,138,255,.15);}.md .admonition-title{font-weight:bold;border-bottom:solid 1px rgba(68,138,255,.4);padding-bottom:4px;margin-bottom:4px;margin-left: -1rem;padding-left:1rem;margin-right:-1rem;border-color:rgba(68,138,255,.4)}.md .admonition.tip{border-left:2.5rem solid rgba(50,255,90,.4);background-color:rgba(50,255,90,.15)}.md .admonition.tip::before{content:"\24d8";font-weight:bold;font-size:150%;position:relative;top:3px;color:rgba(26,128,46,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.tip>.admonition-title{border-color:rgba(50,255,90,.4)}.md .admonition.warn,.md .admonition.warning{border-left:2.5rem solid rgba(255,145,0,.4);background-color:rgba(255,145,0,.15)}.md .admonition.warn::before,.md .admonition.warning::before{content:"\26A0";font-weight:bold;font-size:150%;position:relative;top:2px;color:rgba(128,73,0,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.warn>.admonition-title,.md .admonition.warning>.admonition-title{border-color:rgba(255,145,0,.4)}.md .admonition.error{border-left: 2.5rem solid rgba(255,23,68,.4);background-color:rgba(255,23,68,.15)}.md .admonition.error>.admonition-title{border-color:rgba(255,23,68,.4)}.md .admonition.error::before{content: "\2612";font-family:"Arial";font-size:200%;position:relative;color:rgba(128,12,34,.8);top:-2px;left:-3rem;display:block;width:0;height:0}.md .admonition p:last-child{margin-bottom:0}</style><style>.md h1::before {
content:counter(h1) " ";
counter-increment: h1;margin-right:10px}.md h2::before {
content:counter(h1) "."counter(h2) " ";
counter-increment: h2;margin-right:10px}.md h3::before {
content:counter(h1) "."counter(h2) "."counter(h3) " ";
counter-increment: h3;margin-right:10px}.md h4::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) " ";
counter-increment: h4;margin-right:10px}.md h5::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) " ";
counter-increment: h5;margin-right:10px}.md h6::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) "."counter(h6) " ";
counter-increment: h6;margin-right:10px}</style><style>.hljs{display:block;overflow-x:auto;padding:0.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword{color:#02E}.hljs-literal,.nginx .hljs-title{color:#aa0d91}.method,.hljs-list .hljs-title,.hljs-tag .hljs-title,.setting .hljs-value,.hljs-winutils,.tex .hljs-command,.http .hljs-title,.hljs-request,.hljs-status,.hljs-name{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.hljs-tag .hljs-value,.hljs-cdata,.hljs-filter .hljs-argument,.hljs-attr_selector,.apache .hljs-cbracket,.hljs-date,.hljs-regexp{color:#080}.hljs-sub .hljs-identifier,.hljs-pi,.hljs-tag,.hljs-tag .hljs-keyword,.hljs-decorator,.ini .hljs-title,.hljs-shebang,.hljs-prompt,.hljs-hexcolor,.hljs-rule .hljs-value,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-number,.css .hljs-function,.hljs-function .hljs-title,.coffeescript .hljs-attribute{color:#A0C}.hljs-function .hljs-title{font-weight:bold;color:#000}.hljs-class .hljs-title,.smalltalk .hljs-class,.hljs-type,.hljs-typename,.hljs-tag .hljs-attribute,.hljs-doctype,.hljs-class .hljs-id,.hljs-built_in,.setting,.hljs-params,.clojure .hljs-attribute{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-rule .hljs-property,.hljs-pseudo,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#ff7700;font-weight:bold}.hljs-rule .hljs-keyword{color:#c5af75}.hljs-annotation,.apache .hljs-sqbracket,.nginx .hljs-built_in{color:#9b859d}.hljs-preprocessor,.hljs-preprocessor *,.hljs-pragma{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:#808080;font-weight:bold}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:bold}.method .hljs-id{color:#000}</style><style>div.title { padding-top: 40px; } div.afterTitles { height: 15px; }</style><meta charset="utf-8" emacsmode="-*- markdown -*-">
<link rel="stylesheet" href="nuklear_files/apidoc.css">
</head><body style="visibility: visible;"><span class="md"><p></p><div class="mediumTOC"><center><b>Contents</b></center><p><a href="#toc1" class="level1"><span class="tocNumber">1&nbsp; </span>Nuklear</a><br>
&nbsp;&nbsp;<a href="#toc1.1" class="level2"><span class="tocNumber">1.1&nbsp; </span>Contents</a><br>
&nbsp;&nbsp;<a href="#toc1.2" class="level2"><span class="tocNumber">1.2&nbsp; </span>About</a><br>
&nbsp;&nbsp;<a href="#toc1.3" class="level2"><span class="tocNumber">1.3&nbsp; </span>Highlights</a><br>
&nbsp;&nbsp;<a href="#toc1.4" class="level2"><span class="tocNumber">1.4&nbsp; </span>Features</a><br>
&nbsp;&nbsp;<a href="#toc1.5" class="level2"><span class="tocNumber">1.5&nbsp; </span>Usage</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.5.1" class="level3"><span class="tocNumber">1.5.1&nbsp; </span>Flags</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.5.2" class="level3"><span class="tocNumber">1.5.2&nbsp; </span>Constants</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.5.3" class="level3"><span class="tocNumber">1.5.3&nbsp; </span>Dependencies</a><br>
&nbsp;&nbsp;<a href="#toc1.6" class="level2"><span class="tocNumber">1.6&nbsp; </span>Example</a><br>
&nbsp;&nbsp;<a href="#toc1.7" class="level2"><span class="tocNumber">1.7&nbsp; </span>API</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.1" class="level3"><span class="tocNumber">1.7.1&nbsp; </span>Context</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.2" class="level3"><span class="tocNumber">1.7.2&nbsp; </span>Input</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.3" class="level3"><span class="tocNumber">1.7.3&nbsp; </span>Drawing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.4" class="level3"><span class="tocNumber">1.7.4&nbsp; </span>Window</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.5" class="level3"><span class="tocNumber">1.7.5&nbsp; </span>Layouting</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.6" class="level3"><span class="tocNumber">1.7.6&nbsp; </span>Groups</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.7" class="level3"><span class="tocNumber">1.7.7&nbsp; </span>Tree</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toc1.7.8" class="level3"><span class="tocNumber">1.7.8&nbsp; </span>Properties</a><br>
&nbsp;&nbsp;<a href="#toc1.8" class="level2"><span class="tocNumber">1.8&nbsp; </span>License</a><br>
&nbsp;&nbsp;<a href="#toc1.9" class="level2"><span class="tocNumber">1.9&nbsp; </span>Changelog</a><br>
&nbsp;&nbsp;<a href="#toc1.10" class="level2"><span class="tocNumber">1.10&nbsp; </span>Gallery</a><br>
&nbsp;&nbsp;<a href="#toc1.11" class="level2"><span class="tocNumber">1.11&nbsp; </span>Credits</a><br>
</p></div>
<a class="target" name="nuklear">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Nuklear</h1>
<p>

</p><center><a href="https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif" target="_blank"><img class="markdeep" src="nuklear_files/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif"></a></center>

<p></p>
<a class="target" name="contents">&nbsp;</a><a class="target" name="toc1.1">&nbsp;</a><h2>Contents</h2>
<p>


</p><ol start="1">
<li class="number"><a href="#about">About</a> section
</li>
<li class="number"><a href="#highlights">Highlights</a> section
</li>
<li class="number"><a href="#features">Features</a> section
</li>
<li class="number"><a href="#usage">Usage</a> section
<ol start="1">
    <li class="number"><a href="#flags">Flags</a> section
</li>
    <li class="number"><a href="#constants">Constants</a> section
</li>
    <li class="number"><a href="#dependencies">Dependencies</a> section
</li></ol>
</li><li class="number"><a href="#example">Example</a> section
</li>
<li class="number"><a href="#api">API</a> section
<ol start="1">
    <li class="number"><a href="#context">Context</a> section
</li>
    <li class="number"><a href="#input">Input</a> section
</li>
    <li class="number"><a href="#drawing">Drawing</a> section
</li>
    <li class="number"><a href="#window">Window</a> section
</li>
    <li class="number"><a href="#layouting">Layouting</a> section
</li>
    <li class="number"><a href="#groups">Groups</a> section
</li>
    <li class="number"><a href="#tree">Tree</a> section
</li>
    <li class="number"><a href="#properties">Properties</a> section
</li></ol>
</li><li class="number"><a href="#license">License</a> section
</li>
<li class="number"><a href="#changelog">Changelog</a> section
</li>
<li class="number"><a href="#gallery">Gallery</a> section
</li>
<li class="number"><a href="#credits">Credits</a> section</li></ol>

<p></p>
<a class="target" name="about">&nbsp;</a><a class="target" name="toc1.2">&nbsp;</a><h2>About</h2>
<p>

This is a minimal state immediate mode graphical user interface toolkit
written in ANSI C and licensed under public domain. It was designed as a simple
embeddable user interface for application and does not have any dependencies,
a default renderbackend or OS window and input handling but instead provides a very modular
library approach by using simple input state for input and draw
commands describing primitive shapes as output. So instead of providing a
layered library that tries to abstract over a number of platform and
render backends it only focuses on the actual UI.

</p>
<a class="target" name="highlights">&nbsp;</a><a class="target" name="toc1.3">&nbsp;</a><h2>Highlights</h2>
<p>


</p><ul>
<li class="minus">Graphical user interface toolkit
</li>
<li class="minus">Single header library
</li>
<li class="minus">Written in C89 (a.k.a. ANSI C or ISO C90)
</li>
<li class="minus">Small codebase (~18kLOC)
</li>
<li class="minus">Focus on portability, efficiency and simplicity
</li>
<li class="minus">No dependencies (not even the standard library if not wanted)
</li>
<li class="minus">Fully skinnable and customizable
</li>
<li class="minus">Low memory footprint with total memory control if needed or wanted
</li>
<li class="minus">UTF-8 support
</li>
<li class="minus">No global or hidden state
</li>
<li class="minus">Customizable library modules (you can compile and use only what you need)
</li>
<li class="minus">Optional font baker and vertex buffer output</li></ul>

<p></p>
<a class="target" name="features">&nbsp;</a><a class="target" name="toc1.4">&nbsp;</a><h2>Features</h2>
<p>


</p><ul>
<li class="minus">Absolutely no platform dependent code
</li>
<li class="minus">Memory management control ranging from/to
<ul>
    <li class="minus">Ease of use by allocating everything from standard library
</li>
    <li class="minus">Control every byte of memory inside the library
</li></ul>
</li><li class="minus">Font handling control ranging from/to
<ul>
    <li class="minus">Use your own font implementation for everything
</li>
    <li class="minus">Use this libraries internal font baking and handling API
</li></ul>
</li><li class="minus">Drawing output control ranging from/to
<ul>
    <li class="minus">Simple shapes for more high level APIs which already have drawing capabilities
</li>
    <li class="minus">Hardware accessible anti-aliased vertex buffer output
</li></ul>
</li><li class="minus">Customizable colors and properties ranging from/to
<ul>
    <li class="minus">Simple changes to color by filling a simple color table
</li>
    <li class="minus">Complete control with ability to use skinning to decorate widgets
</li></ul>
</li><li class="minus">Bendable UI library with widget ranging from/to
<ul>
    <li class="minus">Basic widgets like buttons, checkboxes, slider, ...
</li>
    <li class="minus">Advanced widget like abstract comboboxes, contextual menus,...
</li></ul>
</li><li class="minus">Compile time configuration to only compile what you need
<ul>
    <li class="minus">Subset which can be used if you do not want to link or use the standard library
</li></ul>
</li><li class="minus">Can be easily modified to only update on user input instead of frame updates</li></ul>

<p></p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.5">&nbsp;</a><h2>Usage</h2>
<p>

This library is self contained in one single header file and can be used either
in header only mode or in implementation mode. The header only mode is used
by default when included and allows including this header in other headers
and does not contain the actual implementation. <br><br>
The implementation mode requires to define  the preprocessor macro
NK_IMPLEMENTATION in <em class="asterisk">one</em> .c/.cpp file before #includeing this file, e.g.:
</p><pre class="listing tilde"><code>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NK_IMPLEMENTATION</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nuklear.h"</span></span></code></pre><p>
Also optionally define the symbols listed in the section “OPTIONAL DEFINES”
below in header and implementation mode if you want to use additional functionality
or need more control over the library.

</p><p>

</p><div class="admonition warning">Every time nuklear is included 
define the same compiler flags. This very important not doing so could 
lead to compiler errors or even worse stack corruptions.</div>

<p></p>
<a class="target" name="flags">&nbsp;</a><a class="target" name="toc1.5.1">&nbsp;</a><h3>Flags</h3>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Flag </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> NK_PRIVATE </td><td style="text-align:left"> If defined declares all functions as static, so they can only be accessed inside the file that contains the implementation </td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_FIXED_TYPES </td><td style="text-align:left"> If defined it will include header <code>&lt;stdint.h&gt;</code>
 for fixed sized types otherwise nuklear tries to select the correct 
type. If that fails it will throw a compiler error and you have to 
select the correct types yourself. </td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_DEFAULT_ALLOCATOR </td><td style="text-align:left"> If defined it will include header <code>&lt;stdlib.h&gt;</code>
 and provide additional functions to use this library without caring for
 memory allocation control and therefore ease memory management. </td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_STANDARD_IO </td><td style="text-align:left"> If defined it will include header <code>&lt;stdio.h&gt;</code> and provide additional functions depending on file loading. </td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_STANDARD_VARARGS </td><td style="text-align:left"> If defined it will include header <stdio.h> and provide additional functions depending on file loading. </stdio.h></td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_VERTEX_BUFFER_OUTPUT </td><td style="text-align:left">
 Defining this adds a vertex draw command list backend to this library, 
which allows you to convert queue commands into vertex draw commands. 
This is mainly if you need a hardware accessible format for OpenGL, 
DirectX, Vulkan, Metal,... </td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_FONT_BAKING </td><td style="text-align:left"> Defining this adds <code>stb_truetype</code> and <code>stb_rect_pack</code>
 implementation to this library and provides font baking and rendering. 
If you already have font handling or do not want to use this font 
handler you don't have to define it. </td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_DEFAULT_FONT </td><td style="text-align:left">
 Defining this adds the default font: ProggyClean.ttf into this library 
which can be loaded into a font atlas and allows using this library 
without having a truetype font </td></tr>
<tr><td style="text-align:left"> NK_INCLUDE_COMMAND_USERDATA </td><td style="text-align:left">
 Defining this adds a userdata pointer into each command. Can be useful 
for example if you want to provide custom shaders depending on the used 
widget. Can be combined with the style structures. </td></tr>
<tr><td style="text-align:left"> NK_BUTTON_TRIGGER_ON_RELEASE </td><td style="text-align:left">
 Different platforms require button clicks occurring either on buttons 
being pressed (up to down) or released (down to up). By default this 
library will react on buttons being pressed, but if you define this it 
will only trigger if a button is released. </td></tr>
<tr><td style="text-align:left"> NK_ZERO_COMMAND_MEMORY </td><td style="text-align:left">
 Defining this will zero out memory for each drawing command added to a 
drawing queue (inside nk_command_buffer_push). Zeroing command memory is
 very useful for fast checking (using memcmp) if command buffers are 
equal and avoid drawing frames when nothing on screen has changed since 
previous frame. </td></tr>
</tbody></table></div>

<p></p><p>

</p><div class="admonition warning">The following flags will pull in the standard C library:

<p></p><p>

</p><ul>
    <li class="minus">NK_INCLUDE_DEFAULT_ALLOCATOR
</li>
    <li class="minus">NK_INCLUDE_STANDARD_IO
</li>
    <li class="minus">NK_INCLUDE_STANDARD_VARARGS</li></ul></div>

<p></p><p>

</p><div class="admonition warning">The following flags if defined need to be defined for both header and implementation:

<p></p><p>

</p><ul>
    <li class="minus">NK_INCLUDE_FIXED_TYPES
</li>
    <li class="minus">NK_INCLUDE_DEFAULT_ALLOCATOR
</li>
    <li class="minus">NK_INCLUDE_STANDARD_VARARGS
</li>
    <li class="minus">NK_INCLUDE_VERTEX_BUFFER_OUTPUT
</li>
    <li class="minus">NK_INCLUDE_FONT_BAKING
</li>
    <li class="minus">NK_INCLUDE_DEFAULT_FONT
</li>
    <li class="minus">NK_INCLUDE_STANDARD_VARARGS
</li>
    <li class="minus">NK_INCLUDE_COMMAND_USERDATA</li></ul></div>

<p></p>
<a class="target" name="constants">&nbsp;</a><a class="target" name="toc1.5.2">&nbsp;</a><h3>Constants</h3>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Define </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> NK_BUFFER_DEFAULT_INITIAL_SIZE </td><td style="text-align:left">
 Initial buffer size allocated by all buffers while using the default 
allocator functions included by defining NK_INCLUDE_DEFAULT_ALLOCATOR. 
If you don't want to allocate the default 4k memory then redefine it. </td></tr>
<tr><td style="text-align:left"> NK_MAX_NUMBER_BUFFER </td><td style="text-align:left">
 Maximum buffer size for the conversion buffer between float and string 
Under normal circumstances this should be more than sufficient. </td></tr>
<tr><td style="text-align:left"> NK_INPUT_MAX </td><td style="text-align:left">
 Defines the max number of bytes which can be added as text input in one
 frame. Under normal circumstances this should be more than sufficient. </td></tr>
</tbody></table></div>

<p></p><p>

</p><div class="admonition warning">The following constants if defined need to be defined for both header and implementation:

<p></p><p>

</p><ul>
    <li class="minus">NK_MAX_NUMBER_BUFFER
</li>
    <li class="minus">NK_BUFFER_DEFAULT_INITIAL_SIZE
</li>
    <li class="minus">NK_INPUT_MAX</li></ul></div>

<p></p>
<a class="target" name="dependencies">&nbsp;</a><a class="target" name="toc1.5.3">&nbsp;</a><h3>Dependencies</h3>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> NK_ASSERT </td><td style="text-align:left"> If you don't define this, nuklear will use <assert.h> with assert(). </assert.h></td></tr>
<tr><td style="text-align:left"> NK_MEMSET </td><td style="text-align:left"> You can define this to 'memset' or your own memset implementation replacement. If not nuklear will use its own version. </td></tr>
<tr><td style="text-align:left"> NK_MEMCPY </td><td style="text-align:left"> You can define this to 'memcpy' or your own memcpy implementation replacement. If not nuklear will use its own version. </td></tr>
<tr><td style="text-align:left"> NK_SQRT </td><td style="text-align:left">
 You can define this to 'sqrt' or your own sqrt implementation 
replacement. If not nuklear will use its own slow and not highly 
accurate version. </td></tr>
<tr><td style="text-align:left"> NK_SIN </td><td style="text-align:left">
 You can define this to 'sinf' or your own sine implementation 
replacement. If not nuklear will use its own approximation 
implementation. </td></tr>
<tr><td style="text-align:left"> NK_COS </td><td style="text-align:left">
 You can define this to 'cosf' or your own cosine implementation 
replacement. If not nuklear will use its own approximation 
implementation. </td></tr>
<tr><td style="text-align:left"> NK_STRTOD </td><td style="text-align:left"> You can define this to <code>strtod</code>
 or your own string to double conversion implementation replacement. If 
not defined nuklear will use its own imprecise and possibly unsafe 
version (does not handle nan or infinity!). </td></tr>
<tr><td style="text-align:left"> NK_DTOA </td><td style="text-align:left"> You can define this to <code>dtoa</code>
 or your own double to string conversion implementation replacement. If 
not defined nuklear will use its own imprecise and possibly unsafe 
version (does not handle nan or infinity!). </td></tr>
<tr><td style="text-align:left"> NK_VSNPRINTF </td><td style="text-align:left"> If you define <code>NK_INCLUDE_STANDARD_VARARGS</code> as well as <code>NK_INCLUDE_STANDARD_IO</code> and want to be safe define this to <code>vsnprintf</code>
 on compilers supporting later versions of C or C++. By default nuklear 
will check for your stdlib version in C as well as compiler version in 
C++. if <code>vsnprintf</code> is available it will define it to <code>vsnprintf</code> directly. If not defined and if you have older versions of C or C++ it will be defined to <code>vsprintf</code> which is unsafe. </td></tr>
</tbody></table></div>

<p></p><p>

</p><div class="admonition warning">The following dependencies will pull in the standard C library if not redefined:

<p></p><p>

</p><ul>
    <li class="minus">NK_ASSERT</li></ul></div>

<p></p><p>

</p><div class="admonition warning">The following dependencies if defined need to be defined for both header and implementation:

<p></p><p>

</p><ul>
    <li class="minus">NK_ASSERT</li></ul></div>

<p></p><p>

</p><div class="admonition warning">The following dependencies if defined need to be defined only for the implementation part:

<p></p><p>

</p><ul>
    <li class="minus">NK_MEMSET
</li>
    <li class="minus">NK_MEMCPY
</li>
    <li class="minus">NK_SQRT
</li>
    <li class="minus">NK_SIN
</li>
    <li class="minus">NK_COS
</li>
    <li class="minus">NK_STRTOD
</li>
    <li class="minus">NK_DTOA
</li>
    <li class="minus">NK_VSNPRINTF</li></ul></div>

<p></p>
<a class="target" name="example">&nbsp;</a><a class="target" name="toc1.6">&nbsp;</a><h2>Example</h2>
<pre class="listing tilde"><code><span class="hljs-comment">// init gui state</span>
<span class="hljs-keyword">enum</span> {EASY, HARD};
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> op = EASY;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> value = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i =  <span class="hljs-number">20</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_fixed(&amp;ctx, <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, MAX_MEMORY), MAX_MEMORY, &amp;font);
<span class="hljs-keyword">if</span> (nk_begin(&amp;ctx, <span class="hljs-string">"Show"</span>, nk_rect(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">220</span>, <span class="hljs-number">220</span>),
    NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_CLOSABLE)) {
    <span class="hljs-comment">// fixed widget pixel width</span>
    nk_layout_row_static(&amp;ctx, <span class="hljs-number">30</span>, <span class="hljs-number">80</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (nk_button_label(&amp;ctx, <span class="hljs-string">"button"</span>)) {
        <span class="hljs-comment">// event handling</span>
    }
    <span class="hljs-comment">// fixed widget window ratio width</span>
    nk_layout_row_dynamic(&amp;ctx, <span class="hljs-number">30</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span> (nk_option_label(&amp;ctx, <span class="hljs-string">"easy"</span>, op == EASY)) op = EASY;
    <span class="hljs-keyword">if</span> (nk_option_label(&amp;ctx, <span class="hljs-string">"hard"</span>, op == HARD)) op = HARD;
    <span class="hljs-comment">// custom widget pixel width</span>
    nk_layout_row_begin(&amp;ctx, NK_STATIC, <span class="hljs-number">30</span>, <span class="hljs-number">2</span>);
    {
        nk_layout_row_push(&amp;ctx, <span class="hljs-number">50</span>);
        nk_label(&amp;ctx, <span class="hljs-string">"Volume:"</span>, NK_TEXT_LEFT);
        nk_layout_row_push(&amp;ctx, <span class="hljs-number">110</span>);
        nk_slider_float(&amp;ctx, <span class="hljs-number">0</span>, &amp;value, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.1f</span>);
    }
    nk_layout_row_end(&amp;ctx);
}
nk_end(&amp;ctx);</code></pre><p>
<a href="https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png" target="_blank"><img class="markdeep" src="nuklear_files/584ecd68-675c-11e5-897c-822ef534a876.png"></a>

</p>
<a class="target" name="api">&nbsp;</a><a class="target" name="toc1.7">&nbsp;</a><h2>API</h2>

<a class="target" name="context">&nbsp;</a><a class="target" name="toc1.7.1">&nbsp;</a><h3>Context</h3>
<p>

Contexts are the main entry point and the majestro of nuklear and contain all required state.
They are used for window, memory, input, style, stack, commands and time management and need
to be passed into all nuklear GUI specific functions.

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.1.1">&nbsp;</a><h4>Usage</h4>
<p>

To use a context it first has to be initialized which can be achieved by calling
one of either <code>nk_init_default</code>, <code>nk_init_fixed</code>, <code>nk_init</code>, <code>nk_init_custom</code>.
Each takes in a font handle and a specific way of handling memory. Memory control
hereby ranges from standard library to just specifying a fixed sized block of memory
which nuklear has to manage itself from.
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_xxx(&amp;ctx, ...);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// [...]</span>
    nk_clear(&amp;ctx);
}
nk_free(&amp;ctx);</code></pre>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.1.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_init_default</strong> </td><td style="text-align:left"> Initializes context with standard library memory allocation (malloc,free) </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_init_fixed</strong> </td><td style="text-align:left"> Initializes context from single fixed size memory block </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_init</strong> </td><td style="text-align:left"> Initializes context with memory allocator callbacks for alloc and free </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_init_custom</strong> </td><td style="text-align:left"> Initializes context from two buffers. One for draw commands the other for window/panel/table allocations </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_clear</strong> </td><td style="text-align:left"> Called at the end of the frame to reset and prepare the context for the next frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_free</strong> </td><td style="text-align:left"> Shutdown and free all memory allocated inside the context </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_set_user_data</strong> </td><td style="text-align:left"> Utility function to pass user data to draw command </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_init_default">&nbsp;</a><a class="target" name="toc1.7.1.3">&nbsp;</a><h4>nk_init_default</h4>
<p>

Initializes a <code>nk_context</code> struct with a default standard library allocator.
Should be used if you don't want to be bothered with memory management in nuklear.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_init_default</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> struct nk_user_font *font)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an either stack or heap allocated <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">font</strong> </td><td style="text-align:left"> Must point to a previously initialized font handle for more info look at font documentation </td></tr>
</tbody></table></div>
Returns either <code>false(0)</code> on failure or <code>true(1)</code> on success.

<p></p>
<a class="target" name="nk_init_fixed">&nbsp;</a><a class="target" name="toc1.7.1.4">&nbsp;</a><h4>nk_init_fixed</h4>
<p>

Initializes a <code>nk_context</code> struct from single fixed size memory block
Should be used if you want complete control over nuklear's memory management.
Especially recommended for system with little memory or systems with virtual memory.
For the later case you can just allocate for example 16MB of virtual memory
and only the required amount of memory will actually be committed.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_init_fixed</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">void</span> *memory, nk_size size, <span class="hljs-keyword">const</span> struct nk_user_font *font)</span></span>;</code></pre><p>


</p><div class="admonition warning">make sure the passed memory block is aligned correctly for <code>nk_draw_commands</code>.</div>
<div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an either stack or heap allocated <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">memory</strong> </td><td style="text-align:left"> Must point to a previously allocated memory block </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">size</strong> </td><td style="text-align:left"> Must contain the total size of <strong class="underscore">memory</strong> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">font</strong> </td><td style="text-align:left"> Must point to a previously initialized font handle for more info look at font documentation </td></tr>
</tbody></table></div>
Returns either <code>false(0)</code> on failure or <code>true(1)</code> on success.

<p></p>
<a class="target" name="nk_init">&nbsp;</a><a class="target" name="toc1.7.1.5">&nbsp;</a><h4>nk_init</h4>
<p>

Initializes a <code>nk_context</code> struct with memory allocation callbacks for nuklear to allocate
memory from. Used internally for <code>nk_init_default</code> and provides a kitchen sink allocation
interface to nuklear. Can be useful for cases like monitoring memory consumption.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_init</span><span class="hljs-params">(struct nk_context *ctx, struct nk_allocator *alloc, <span class="hljs-keyword">const</span> struct nk_user_font *font)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an either stack or heap allocated <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">alloc</strong> </td><td style="text-align:left"> Must point to a previously allocated memory allocator </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">font</strong> </td><td style="text-align:left"> Must point to a previously initialized font handle for more info look at font documentation </td></tr>
</tbody></table></div>
Returns either <code>false(0)</code> on failure or <code>true(1)</code> on success.

<p></p>
<a class="target" name="nk_init_custom">&nbsp;</a><a class="target" name="toc1.7.1.6">&nbsp;</a><h4>nk_init_custom</h4>
<p>

Initializes a <code>nk_context</code> struct from two different either fixed or growing
buffers. The first buffer is for allocating draw commands while the second buffer is
used for allocating windows, panels and state tables.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_init_custom</span><span class="hljs-params">(struct nk_context *ctx, struct nk_buffer *cmds, struct nk_buffer *pool, <span class="hljs-keyword">const</span> struct nk_user_font *font)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an either stack or heap allocated <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">cmds</strong> </td><td style="text-align:left"> Must point to a previously initialized memory buffer either fixed or dynamic to store draw commands into </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">pool</strong> </td><td style="text-align:left"> Must point to a previously initialized memory buffer either fixed or dynamic to store windows, panels and tables </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">font</strong> </td><td style="text-align:left"> Must point to a previously initialized font handle for more info look at font documentation </td></tr>
</tbody></table></div>
Returns either <code>false(0)</code> on failure or <code>true(1)</code> on success.

<p></p>
<a class="target" name="nk_clear">&nbsp;</a><a class="target" name="toc1.7.1.7">&nbsp;</a><h4>nk_clear</h4>
<p>

Resets the context state at the end of the frame. This includes mostly
garbage collector tasks like removing windows or table not called and therefore
used anymore.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_clear</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_free">&nbsp;</a><a class="target" name="toc1.7.1.8">&nbsp;</a><h4>nk_free</h4>
<p>

Frees all memory allocated by nuklear. Not needed if context was
initialized with <code>nk_init_fixed</code>.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_free</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_set_user_data">&nbsp;</a><a class="target" name="toc1.7.1.9">&nbsp;</a><h4>nk_set_user_data</h4>
<p>

Sets the currently passed userdata passed down into each draw command.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_set_user_data</span><span class="hljs-params">(struct nk_context *ctx, nk_handle data)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">data</strong> </td><td style="text-align:left"> Handle with either pointer or index to be passed into every draw commands </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="input">&nbsp;</a><a class="target" name="toc1.7.2">&nbsp;</a><h3>Input</h3>
<p>

The input API is responsible for holding the current input state composed of
mouse, key and text input states.
It is worth noting that no direct os or window handling is done in nuklear.
Instead all input state has to be provided by platform specific code. This in one hand
expects more work from the user and complicates usage but on the other hand
provides simple abstraction over a big number of platforms, libraries and other
already provided functionality.
</p><pre class="listing tilde"><code>nk_input_begin(&amp;ctx);
<span class="hljs-keyword">while</span> (GetEvent(&amp;evt)) {
    <span class="hljs-keyword">if</span> (evt.type == MOUSE_MOVE)
        nk_input_motion(&amp;ctx, evt.motion.x, evt.motion.y);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evt.type == [...]) {
        <span class="hljs-comment">// [...]</span>
    }
} nk_input_end(&amp;ctx);</code></pre>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.2.1">&nbsp;</a><h4>Usage</h4>
<p>

Input state needs to be provided to nuklear by first calling <code>nk_input_begin</code>
which resets internal state like delta mouse position and button transistions.
After <code>nk_input_begin</code> all current input state needs to be provided. This includes
mouse motion, button and key pressed and released, text input and scrolling.
Both event- or state-based input handling are supported by this API
and should work without problems. Finally after all input state has been
mirrored <code>nk_input_end</code> needs to be called to finish input process.
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_xxx(&amp;ctx, ...);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    Event evt;
    nk_input_begin(&amp;ctx);
    <span class="hljs-keyword">while</span> (GetEvent(&amp;evt)) {
        <span class="hljs-keyword">if</span> (evt.type == MOUSE_MOVE)
            nk_input_motion(&amp;ctx, evt.motion.x, evt.motion.y);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evt.type == [...]) {
            <span class="hljs-comment">// [...]</span>
        }
    }
    nk_input_end(&amp;ctx);
    <span class="hljs-comment">// [...]</span>
    nk_clear(&amp;ctx);
} nk_free(&amp;ctx);</code></pre>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.2.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_begin</strong> </td><td style="text-align:left"> Begins the input mirroring process. Needs to be called before all other <code>nk_input_xxx</code> calls </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_motion</strong> </td><td style="text-align:left"> Mirrors mouse cursor position </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_key</strong> </td><td style="text-align:left"> Mirrors key state with either pressed or released </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_button</strong> </td><td style="text-align:left"> Mirrors mouse button state with either pressed or released </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_scroll</strong> </td><td style="text-align:left"> Mirrors mouse scroll values </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_char</strong> </td><td style="text-align:left"> Adds a single ASCII text character into an internal text buffer </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_glyph</strong> </td><td style="text-align:left"> Adds a single multi-byte UTF-8 character into an internal text buffer </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_unicode</strong> </td><td style="text-align:left"> Adds a single unicode rune into an internal text buffer </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_input_end</strong> </td><td style="text-align:left"> Ends the input mirroring process by calculating state changes. Don't call any <code>nk_input_xxx</code> function referenced above after this call </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_begin">&nbsp;</a><a class="target" name="toc1.7.2.3">&nbsp;</a><h4>nk_input_begin</h4>
<p>

Begins the input mirroring process by resetting text, scroll
mouse previous mouse position and movement as well as key state transitions,
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_begin</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_motion">&nbsp;</a><a class="target" name="toc1.7.2.4">&nbsp;</a><h4>nk_input_motion</h4>
<p>

Mirrors current mouse position to nuklear
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_motion</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">x</strong> </td><td style="text-align:left"> Must hold an integer describing the current mouse cursor x-position </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">y</strong> </td><td style="text-align:left"> Must hold an integer describing the current mouse cursor y-position </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_key">&nbsp;</a><a class="target" name="toc1.7.2.5">&nbsp;</a><h4>nk_input_key</h4>
<p>

Mirrors state of a specific key to nuklear
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_key</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">enum</span> nk_keys key, <span class="hljs-keyword">int</span> down)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">key</strong> </td><td style="text-align:left"> Must be any value specified in enum <code>nk_keys</code> that needs to be mirrored </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">down</strong> </td><td style="text-align:left"> Must be 0 for key is up and 1 for key is down </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_button">&nbsp;</a><a class="target" name="toc1.7.2.6">&nbsp;</a><h4>nk_input_button</h4>
<p>

Mirrors the state of a specific mouse button to nuklear
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_button</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">enum</span> nk_buttons btn, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> down)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">btn</strong> </td><td style="text-align:left"> Must be any value specified in enum <code>nk_buttons</code> that needs to be mirrored </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">x</strong> </td><td style="text-align:left"> Must contain an integer describing mouse cursor x-position on click up/down </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">y</strong> </td><td style="text-align:left"> Must contain an integer describing mouse cursor y-position on click up/down </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">down</strong> </td><td style="text-align:left"> Must be 0 for key is up and 1 for key is down </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_scroll">&nbsp;</a><a class="target" name="toc1.7.2.7">&nbsp;</a><h4>nk_input_scroll</h4>
<p>

Copies the last mouse scroll value to nuklear. Is generally
a scroll value. So does not have to come from mouse and could also originate
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_scroll</span><span class="hljs-params">(struct nk_context *ctx, struct nk_vec2 val)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">val</strong> </td><td style="text-align:left"> vector with both X- as well as Y-scroll value </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_char">&nbsp;</a><a class="target" name="toc1.7.2.8">&nbsp;</a><h4>nk_input_char</h4>
<p>

Copies a single ASCII character into an internal text buffer
This is basically a helper function to quickly push ASCII characters into
nuklear.

</p><p>

</p><div class="admonition note">Stores up to NK_INPUT_MAX bytes between <code>nk_input_begin</code> and <code>nk_input_end</code>.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_char</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">char</span> c)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">c</strong> </td><td style="text-align:left"> Must be a single ASCII character preferable one that can be printed </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_glyph">&nbsp;</a><a class="target" name="toc1.7.2.9">&nbsp;</a><h4>nk_input_glyph</h4>
<p>

Converts an encoded unicode rune into UTF-8 and copies the result into an
internal text buffer.

</p><p>

</p><div class="admonition note">Stores up to NK_INPUT_MAX bytes between <code>nk_input_begin</code> and <code>nk_input_end</code>.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_glyph</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> nk_glyph g)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">g</strong> </td><td style="text-align:left"> UTF-32 unicode codepoint </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_unicode">&nbsp;</a><a class="target" name="toc1.7.2.10">&nbsp;</a><h4>nk_input_unicode</h4>
<p>

Converts a unicode rune into UTF-8 and copies the result
into an internal text buffer.

</p><p>

</p><div class="admonition note">Stores up to NK_INPUT_MAX bytes between <code>nk_input_begin</code> and <code>nk_input_end</code>.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_unicode</span><span class="hljs-params">(struct nk_context*, nk_rune rune)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">rune</strong> </td><td style="text-align:left"> UTF-32 unicode codepoint </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_input_end">&nbsp;</a><a class="target" name="toc1.7.2.11">&nbsp;</a><h4>nk_input_end</h4>
<p>

End the input mirroring process by resetting mouse grabbing
state to ensure the mouse cursor is not grabbed indefinitely.///
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_input_end</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to a previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="drawing">&nbsp;</a><a class="target" name="toc1.7.3">&nbsp;</a><h3>Drawing</h3>
<p>

This library was designed to be render backend agnostic so it does
not draw anything to screen directly. Instead all drawn shapes, widgets
are made of, are buffered into memory and make up a command queue.
Each frame therefore fills the command buffer with draw commands
that then need to be executed by the user and his own render backend.
After that the command buffer needs to be cleared and a new frame can be
started. It is probably important to note that the command buffer is the main
drawing API and the optional vertex buffer API only takes this format and
converts it into a hardware accessible format.

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.3.1">&nbsp;</a><h4>Usage</h4>
<p>

To draw all draw commands accumulated over a frame you need your own render
backend able to draw a number of 2D primitives. This includes at least
filled and stroked rectangles, circles, text, lines, triangles and scissors.
As soon as this criterion is met you can iterate over each draw command
and execute each draw command in a interpreter like fashion:
</p><pre class="listing tilde"><code><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_command</span> *<span class="hljs-title">cmd</span> = 0;</span>
nk_foreach(cmd, &amp;ctx) {
    <span class="hljs-keyword">switch</span> (cmd-&gt;type) {
    <span class="hljs-keyword">case</span> NK_COMMAND_LINE:
        your_draw_line_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-function"><span class="hljs-keyword">case</span> NK_COMMAND_RECT
        <span class="hljs-title">your_draw_rect_function</span><span class="hljs-params">(...)</span>
        <span class="hljs-keyword">break</span></span>;
    <span class="hljs-keyword">case</span> <span class="hljs-comment">//...:</span>
        <span class="hljs-comment">//[...]</span>
    }
}</code></pre><p>
In program flow context draw commands need to be executed after input has been
gathered and the complete UI with windows and their contained widgets have
been executed and before calling <code>nk_clear</code> which frees all previously
allocated draw commands.
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_xxx(&amp;ctx, ...);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    Event evt;
    nk_input_begin(&amp;ctx);
    <span class="hljs-keyword">while</span> (GetEvent(&amp;evt)) {
        <span class="hljs-keyword">if</span> (evt.type == MOUSE_MOVE)
            nk_input_motion(&amp;ctx, evt.motion.x, evt.motion.y);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evt.type == [...]) {
            [...]
        }
    }
    nk_input_end(&amp;ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// [...]</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_command</span> *<span class="hljs-title">cmd</span> = 0;</span>
    nk_foreach(cmd, &amp;ctx) {
    <span class="hljs-keyword">switch</span> (cmd-&gt;type) {
    <span class="hljs-keyword">case</span> NK_COMMAND_LINE:
        your_draw_line_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-function"><span class="hljs-keyword">case</span> NK_COMMAND_RECT
        <span class="hljs-title">your_draw_rect_function</span><span class="hljs-params">(...)</span>
        <span class="hljs-keyword">break</span></span>;
    <span class="hljs-keyword">case</span> ...:
        <span class="hljs-comment">// [...]</span>
    }
    nk_clear(&amp;ctx);
}
nk_free(&amp;ctx);</code></pre><p>
You probably noticed that you have to draw all of the UI each frame which is
quite wasteful. While the actual UI updating loop is quite fast rendering
without actually needing it is not. So there are multiple things you could do.
First is only update on input. This of course is only an option if your
application only depends on the UI and does not require any outside calculations.
If you actually only update on input make sure to update the UI two times each
frame and call <code>nk_clear</code> directly after the first pass and only draw in
the second pass. In addition it is recommended to also add additional timers
to make sure the UI is not drawn more than a fixed number of frames per second.
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_xxx(&amp;ctx, ...);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// [...wait for input ]</span>
    <span class="hljs-comment">// [...do two UI passes ...]</span>
    do_ui(...)
    nk_clear(&amp;ctx);
    do_ui(...)
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// draw</span>
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_command</span> *<span class="hljs-title">cmd</span> = 0;</span>
    nk_foreach(cmd, &amp;ctx) {
    <span class="hljs-keyword">switch</span> (cmd-&gt;type) {
    <span class="hljs-keyword">case</span> NK_COMMAND_LINE:
        your_draw_line_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-function"><span class="hljs-keyword">case</span> NK_COMMAND_RECT
        <span class="hljs-title">your_draw_rect_function</span><span class="hljs-params">(...)</span>
        <span class="hljs-keyword">break</span></span>;
    <span class="hljs-keyword">case</span> ...:
        <span class="hljs-comment">//[...]</span>
    }
    nk_clear(&amp;ctx);
}
nk_free(&amp;ctx);</code></pre><p>
The second probably more applicable trick is to only draw if anything changed.
It is not really useful for applications with continuous draw loop but
quite useful for desktop applications. To actually get nuklear to only
draw on changes you first have to define <code>NK_ZERO_COMMAND_MEMORY</code> and
allocate a memory buffer that will store each unique drawing output.
After each frame you compare the draw command memory inside the library
with your allocated buffer by memcmp. If memcmp detects differences
you have to copy the command buffer into the allocated buffer
and then draw like usual (this example uses fixed memory but you could
use dynamically allocated memory).
</p><pre class="listing tilde"><code><span class="hljs-comment">//[... other defines ...]</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NK_ZERO_COMMAND_MEMORY</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nuklear.h"</span></span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// setup context</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
<span class="hljs-keyword">void</span> *last = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>);
<span class="hljs-keyword">void</span> *buf = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>);
nk_init_fixed(&amp;ctx, buf, <span class="hljs-number">64</span>*<span class="hljs-number">1024</span>);
<span class="hljs-comment">//</span>
<span class="hljs-comment">// loop</span>
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// [...input...]</span>
    <span class="hljs-comment">// [...ui...]</span>
    <span class="hljs-keyword">void</span> *cmds = nk_buffer_memory(&amp;ctx.memory);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(cmds, last, ctx.memory.allocated)) {
        <span class="hljs-built_in">memcpy</span>(last,cmds,ctx.memory.allocated);
        <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_command</span> *<span class="hljs-title">cmd</span> = 0;</span>
        nk_foreach(cmd, &amp;ctx) {
            <span class="hljs-keyword">switch</span> (cmd-&gt;type) {
            <span class="hljs-keyword">case</span> NK_COMMAND_LINE:
                your_draw_line_function(...)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-function"><span class="hljs-keyword">case</span> NK_COMMAND_RECT
                <span class="hljs-title">your_draw_rect_function</span><span class="hljs-params">(...)</span>
                <span class="hljs-keyword">break</span></span>;
            <span class="hljs-keyword">case</span> ...:
                <span class="hljs-comment">// [...]</span>
            }
        }
    }
    nk_clear(&amp;ctx);
}
nk_free(&amp;ctx);</code></pre><p>
Finally while using draw commands makes sense for higher abstracted platforms like
X11 and Win32 or drawing libraries it is often desirable to use graphics
hardware directly. Therefore it is possible to just define
<code>NK_INCLUDE_VERTEX_BUFFER_OUTPUT</code> which includes optional vertex output.
To access the vertex output you first have to convert all draw commands into
vertexes by calling <code>nk_convert</code> which takes in your preferred vertex format.
After successfully converting all draw commands just iterate over and execute all
vertex draw commands:
</p><pre class="listing tilde"><code><span class="hljs-comment">// fill configuration</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_convert_config</span> <span class="hljs-title">cfg</span> = {</span>};
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_draw_vertex_layout_element</span> <span class="hljs-title">vertex_layout</span>[] = {</span>
    {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, pos)},
    {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, uv)},
    {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct your_vertex, col)},
    {NK_VERTEX_LAYOUT_END}
};
cfg.shape_AA = NK_ANTI_ALIASING_ON;
cfg.line_AA = NK_ANTI_ALIASING_ON;
cfg.vertex_layout = vertex_layout;
cfg.vertex_size = <span class="hljs-keyword">sizeof</span>(struct your_vertex);
cfg.vertex_alignment = NK_ALIGNOF(struct your_vertex);
cfg.circle_segment_count = <span class="hljs-number">22</span>;
cfg.curve_segment_count = <span class="hljs-number">22</span>;
cfg.arc_segment_count = <span class="hljs-number">22</span>;
cfg.global_alpha = <span class="hljs-number">1.0f</span>;
cfg.null = dev-&gt;null;
<span class="hljs-comment">//</span>
<span class="hljs-comment">// setup buffers and convert</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_buffer</span> <span class="hljs-title">cmds</span>, <span class="hljs-title">verts</span>, <span class="hljs-title">idx</span>;</span>
nk_buffer_init_default(&amp;cmds);
nk_buffer_init_default(&amp;verts);
nk_buffer_init_default(&amp;idx);
nk_convert(&amp;ctx, &amp;cmds, &amp;verts, &amp;idx, &amp;cfg);
<span class="hljs-comment">//</span>
<span class="hljs-comment">// draw</span>
nk_draw_foreach(cmd, &amp;ctx, &amp;cmds) {
<span class="hljs-keyword">if</span> (!cmd-&gt;elem_count) <span class="hljs-keyword">continue</span>;
    <span class="hljs-comment">//[...]</span>
}
nk_buffer_free(&amp;cms);
nk_buffer_free(&amp;verts);
nk_buffer_free(&amp;idx);</code></pre>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.3.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_<em class="underscore">begin</em></strong><em class="underscore"> </em></td><td style="text-align:left"> Returns the first draw command in the context draw command list to be drawn </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_next</strong> </td><td style="text-align:left"> Increments the draw command iterator to the next command inside the context draw command list </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_foreach</strong> </td><td style="text-align:left"> Iterates over each draw command inside the context draw command list </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_convert</strong> </td><td style="text-align:left"> Converts from the abstract draw commands list into a hardware accessible vertex format </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_draw_begin</strong> </td><td style="text-align:left"> Returns the first vertex command in the context vertex draw list to be executed </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_<em class="underscore">draw_next</em></strong><em class="underscore"> </em></td><td style="text-align:left"> Increments the vertex command iterator to the next command inside the context vertex command list </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_draw_end</strong> </td><td style="text-align:left"> Returns the end of the vertex draw list </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">nk_draw_foreach</strong> </td><td style="text-align:left"> Iterates over each vertex draw command inside the vertex draw list </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk__begin">&nbsp;</a><a class="target" name="toc1.7.3.3">&nbsp;</a><h4>nk__begin</h4>
<p>

Returns a draw command list iterator to iterate all draw
commands accumulated over one frame.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">const</span> struct nk_command* <span class="hljs-title">nk__begin</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
</tbody></table></div>
Returns draw command pointer pointing to the first command inside the draw command list

<p></p>
<a class="target" name="nk__next">&nbsp;</a><a class="target" name="toc1.7.3.4">&nbsp;</a><h4>nk__next</h4>
<p>

Returns a draw command list iterator to iterate all draw
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">const</span> struct nk_command* <span class="hljs-title">nk__next</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> struct nk_command*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">cmd</strong> </td><td style="text-align:left"> Must point to an previously a draw command either returned by <code>nk__begin</code> or <code>nk__next</code> </td></tr>
</tbody></table></div>
Returns draw command pointer pointing to the next command inside the draw command list

<p></p>
<a class="target" name="nk_foreach">&nbsp;</a><a class="target" name="toc1.7.3.5">&nbsp;</a><h4>nk_foreach</h4>
<p>

Iterates over each draw command inside the context draw command list
</p><pre class="listing tilde"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nk_foreach(c, ctx)</span></code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">cmd</strong> </td><td style="text-align:left"> Command pointer initialized to NULL </td></tr>
</tbody></table></div>
Returns draw command pointer pointing to the next command inside the draw command list

<p></p>
<a class="target" name="nk_convert">&nbsp;</a><a class="target" name="toc1.7.3.6">&nbsp;</a><h4>nk_convert</h4>
<p>

Converts all internal draw commands into vertex draw commands and fills
three buffers with vertexes, vertex draw commands and vertex indices. The vertex format
as well as some other configuration values have to be configured by filling out a
<code>nk_convert_config</code> struct.
</p><pre class="listing tilde"><code>nk_flags nk_convert(struct nk_context *ctx, struct nk_buffer *cmds,</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">cmds</strong> </td><td style="text-align:left"> Must point to a previously initialized buffer to hold converted vertex draw commands </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">vertices</strong> </td><td style="text-align:left"> Must point to a previously initialized buffer to hold all produced vertices </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">elements</strong> </td><td style="text-align:left"> Must point to a previously initialized buffer to hold all produced vertex indices </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">config</strong> </td><td style="text-align:left"> Must point to a filled out <code>nk_config</code> struct to configure the conversion process </td></tr>
</tbody></table></div>
Returns one of enum nk_convert_result error codes<div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> NK_CONVERT_SUCCESS </td><td style="text-align:left"> Signals a successful draw command to vertex buffer conversion </td></tr>
<tr><td style="text-align:left"> NK_CONVERT_INVALID_PARAM </td><td style="text-align:left"> An invalid argument was passed in the function call </td></tr>
<tr><td style="text-align:left"> NK_CONVERT_COMMAND_BUFFER_FULL </td><td style="text-align:left"> The provided buffer for storing draw commands is full or failed to allocate more memory </td></tr>
<tr><td style="text-align:left"> NK_CONVERT_VERTEX_BUFFER_FULL </td><td style="text-align:left"> The provided buffer for storing vertices is full or failed to allocate more memory </td></tr>
<tr><td style="text-align:left"> NK_CONVERT_ELEMENT_BUFFER_FULL </td><td style="text-align:left"> The provided buffer for storing indicies is full or failed to allocate more memory </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk__draw_begin">&nbsp;</a><a class="target" name="toc1.7.3.7">&nbsp;</a><h4>nk__draw_begin</h4>
<p>

Returns a draw vertex command buffer iterator to iterate each the vertex draw command buffer
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">const</span> struct nk_draw_command* <span class="hljs-title">nk__draw_begin</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context*, <span class="hljs-keyword">const</span> struct nk_buffer*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">buf</strong> </td><td style="text-align:left"> Must point to an previously by <code>nk_convert</code> filled out vertex draw command buffer </td></tr>
</tbody></table></div>
Returns vertex draw command pointer pointing to the first command inside the vertex draw command buffer

<p></p>
<a class="target" name="nk__draw_end">&nbsp;</a><a class="target" name="toc1.7.3.8">&nbsp;</a><h4>nk__draw_end</h4>
<p>

Returns the vertex draw command at the end of the vertex draw command buffer
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">const</span> struct nk_draw_command* <span class="hljs-title">nk__draw_end</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context *ctx, <span class="hljs-keyword">const</span> struct nk_buffer *buf)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">buf</strong> </td><td style="text-align:left"> Must point to an previously by <code>nk_convert</code> filled out vertex draw command buffer </td></tr>
</tbody></table></div>
Returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer

<p></p>
<a class="target" name="nk__draw_next">&nbsp;</a><a class="target" name="toc1.7.3.9">&nbsp;</a><h4>nk__draw_next</h4>
<p>

Increments the vertex draw command buffer iterator
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">const</span> struct nk_draw_command* <span class="hljs-title">nk__draw_next</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_draw_command*, <span class="hljs-keyword">const</span> struct nk_buffer*, <span class="hljs-keyword">const</span> struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">cmd</strong> </td><td style="text-align:left"> Must point to an previously either by <code>nk__draw_begin</code> or <code>nk__draw_next</code> returned vertex draw command </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">buf</strong> </td><td style="text-align:left"> Must point to an previously by <code>nk_convert</code> filled out vertex draw command buffer </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
</tbody></table></div>
Returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer

<p></p>
<a class="target" name="nk_draw_foreach">&nbsp;</a><a class="target" name="toc1.7.3.10">&nbsp;</a><h4>nk_draw_foreach</h4>
<p>

Iterates over each vertex draw command inside a vertex draw command buffer
</p><pre class="listing tilde"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nk_draw_foreach(cmd,ctx, b)</span></code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">cmd</strong> </td><td style="text-align:left"> <code>nk_draw_command</code>iterator set to NULL </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">buf</strong> </td><td style="text-align:left"> Must point to an previously by <code>nk_convert</code> filled out vertex draw command buffer </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct at the end of a frame </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="window">&nbsp;</a><a class="target" name="toc1.7.4">&nbsp;</a><h3>Window</h3>
<p>

Windows are the main persistent state used inside nuklear and are life time
controlled by simply “retouching” (i.e. calling) each window each frame.
All widgets inside nuklear can only be added inside function pair <code>nk_begin_xxx</code>
and <code>nk_end</code>. Calling any widgets outside these two functions will result in an
assert in debug or no state change in release mode.<br><br>
Each window holds frame persistent state like position, size, flags, state tables,
and some garbage collected internal persistent widget state. Each window
is linked into a window stack list which determines the drawing and overlapping
order. The topmost window thereby is the currently active window.<br><br>
To change window position inside the stack occurs either automatically by
user input by being clicked on or programmatically by calling <code>nk_window_focus</code>.
Windows by default are visible unless explicitly being defined with flag
<code>NK_WINDOW_HIDDEN</code>, the user clicked the close button on windows with flag
<code>NK_WINDOW_CLOSABLE</code> or if a window was explicitly hidden by calling
<code>nk_window_show</code>. To explicitly close and destroy a window call <code>nk_window_close</code>.<br><br>

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.4.1">&nbsp;</a><h4>Usage</h4>
<p>

To create and keep a window you have to call one of the two <code>nk_begin_xxx</code>
functions to start window declarations and <code>nk_end</code> at the end. Furthermore it
is recommended to check the return value of <code>nk_begin_xxx</code> and only process
widgets inside the window if the value is not 0. Either way you have to call
<code>nk_end</code> at the end of window declarations. Furthermore, do not attempt to
nest <code>nk_begin_xxx</code> calls which will hopefully result in an assert or if not
in a segmentation fault.
</p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
    <span class="hljs-comment">// [... widgets ...]</span>
}
nk_end(ctx);</code></pre><p>
In the grand concept window and widget declarations need to occur after input
handling and before drawing to screen. Not doing so can result in higher
latency or at worst invalid behavior. Furthermore make sure that <code>nk_clear</code>
is called at the end of the frame. While nuklear's default platform backends
already call <code>nk_clear</code> for you if you write your own backend not calling
<code>nk_clear</code> can cause asserts or even worse undefined behavior.
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_xxx(&amp;ctx, ...);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    Event evt;
    nk_input_begin(&amp;ctx);
    <span class="hljs-keyword">while</span> (GetEvent(&amp;evt)) {
        <span class="hljs-keyword">if</span> (evt.type == MOUSE_MOVE)
            nk_input_motion(&amp;ctx, evt.motion.x, evt.motion.y);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evt.type == [...]) {
            nk_input_xxx(...);
        }
    }
    nk_input_end(&amp;ctx);
    <span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
        <span class="hljs-comment">//[...]</span>
    }
    nk_end(ctx);
    <span class="hljs-keyword">const</span> struct nk_command *cmd = <span class="hljs-number">0</span>;
    nk_foreach(cmd, &amp;ctx) {
    <span class="hljs-keyword">case</span> NK_COMMAND_LINE:
        your_draw_line_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> NK_COMMAND_RECT
        your_draw_rect_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-comment">//...:</span>
        <span class="hljs-comment">//[...]</span>
    }
    nk_clear(&amp;ctx);
}
nk_free(&amp;ctx);</code></pre>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.4.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> nk_begin </td><td style="text-align:left"> Starts a new window; needs to be called every frame for every window (unless hidden) or otherwise the window gets removed </td></tr>
<tr><td style="text-align:left"> nk_begin_titled </td><td style="text-align:left"> Extended window start with separated title and identifier to allow multiple windows with same name but not title </td></tr>
<tr><td style="text-align:left"> nk_end </td><td style="text-align:left"> Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup </td></tr>
<tr><td style="text-align:left"> nk_window_find </td><td style="text-align:left"> Finds and returns the window with give name </td></tr>
<tr><td style="text-align:left"> nk_window_get_bounds </td><td style="text-align:left"> Returns a rectangle with screen position and size of the currently processed window. </td></tr>
<tr><td style="text-align:left"> nk_window_get_position </td><td style="text-align:left"> Returns the position of the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_size </td><td style="text-align:left"> Returns the size with width and height of the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_width </td><td style="text-align:left"> Returns the width of the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_height </td><td style="text-align:left"> Returns the height of the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_panel </td><td style="text-align:left"> Returns the underlying panel which contains all processing state of the current window </td></tr>
<tr><td style="text-align:left"> nk_window_get_content_region </td><td style="text-align:left"> Returns the position and size of the currently visible and non-clipped space inside the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_content_region_min </td><td style="text-align:left"> Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_content_region_max </td><td style="text-align:left"> Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_content_region_size </td><td style="text-align:left"> Returns the size of the currently visible and non-clipped space inside the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_get_canvas </td><td style="text-align:left"> Returns the draw command buffer. Can be used to draw custom widgets </td></tr>
<tr><td style="text-align:left"> nk_window_has_focus </td><td style="text-align:left"> Returns if the currently processed window is currently active </td></tr>
<tr><td style="text-align:left"> nk_window_is_collapsed </td><td style="text-align:left"> Returns if the window with given name is currently minimized/collapsed </td></tr>
<tr><td style="text-align:left"> nk_window_is_closed </td><td style="text-align:left"> Returns if the currently processed window was closed </td></tr>
<tr><td style="text-align:left"> nk_window_is_hidden </td><td style="text-align:left"> Returns if the currently processed window was hidden </td></tr>
<tr><td style="text-align:left"> nk_window_is_active </td><td style="text-align:left"> Same as nk_window_has_focus for some reason </td></tr>
<tr><td style="text-align:left"> nk_window_is_hovered </td><td style="text-align:left"> Returns if the currently processed window is currently being hovered by mouse </td></tr>
<tr><td style="text-align:left"> nk_window_is_any_hovered </td><td style="text-align:left"> Return if any window currently hovered </td></tr>
<tr><td style="text-align:left"> nk_item_is_any_active </td><td style="text-align:left"> Returns if any window or widgets is currently hovered or active </td></tr>
<tr><td style="text-align:left"> nk_window_set_bounds </td><td style="text-align:left"> Updates position and size of the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_set_position </td><td style="text-align:left"> Updates position of the currently process window </td></tr>
<tr><td style="text-align:left"> nk_window_set_size </td><td style="text-align:left"> Updates the size of the currently processed window </td></tr>
<tr><td style="text-align:left"> nk_window_set_focus </td><td style="text-align:left"> Set the currently processed window as active window </td></tr>
<tr><td style="text-align:left"> nk_window_close </td><td style="text-align:left"> Closes the window with given window name which deletes the window at the end of the frame </td></tr>
<tr><td style="text-align:left"> nk_window_collapse </td><td style="text-align:left"> Collapses the window with given window name </td></tr>
<tr><td style="text-align:left"> nk_window_collapse_if </td><td style="text-align:left"> Collapses the window with given window name if the given condition was met </td></tr>
<tr><td style="text-align:left"> nk_window_show </td><td style="text-align:left"> Hides a visible or reshows a hidden window </td></tr>
<tr><td style="text-align:left"> nk_window_show_if </td><td style="text-align:left"> Hides/shows a window depending on condition </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_panel_flags">&nbsp;</a><a class="target" name="toc1.7.4.3">&nbsp;</a><h4>nk_panel_flags</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Flag </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> NK_WINDOW_BORDER </td><td style="text-align:left"> Draws a border around the window to visually separate window from the background </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_MOVABLE </td><td style="text-align:left"> The movable flag indicates that a window can be moved by user input or by dragging the window header </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_SCALABLE </td><td style="text-align:left"> The scalable flag indicates that a window can be scaled by user input by dragging a scaler icon at the button of the window </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_CLOSABLE </td><td style="text-align:left"> Adds a closable icon into the header </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_MINIMIZABLE </td><td style="text-align:left"> Adds a minimize icon into the header </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_NO_SCROLLBAR </td><td style="text-align:left"> Removes the scrollbar from the window </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_TITLE </td><td style="text-align:left"> Forces a header at the top at the window showing the title </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_SCROLL_AUTO_HIDE </td><td style="text-align:left"> Automatically hides the window scrollbar if no user interaction: also requires delta time in <code>nk_context</code> to be set each frame </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_BACKGROUND </td><td style="text-align:left"> Always keep window in the background </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_SCALE_LEFT </td><td style="text-align:left"> Puts window scaler in the left-ottom corner instead right-bottom </td></tr>
<tr><td style="text-align:left"> NK_WINDOW_NO_INPUT </td><td style="text-align:left"> Prevents window of scaling, moving or getting focus </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_collapse_states">&nbsp;</a><a class="target" name="toc1.7.4.4">&nbsp;</a><h4>nk_collapse_states</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> State </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">NK_MINIMIZED</strong> </td><td style="text-align:left"> UI section is collased and not visibile until maximized </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">NK_MAXIMIZED</strong> </td><td style="text-align:left"> UI section is extended and visibile until minimized </td></tr>
</tbody></table></div>
<br><br>

<p></p>
<a class="target" name="nk_begin">&nbsp;</a><a class="target" name="toc1.7.4.5">&nbsp;</a><h4>nk_begin</h4>
<p>

Starts a new window; needs to be called every frame for every
window (unless hidden) or otherwise the window gets removed
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_begin</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, struct nk_rect bounds, nk_flags flags)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Window title and identifier. Needs to be persistent over frames to identify the window </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">bounds</strong> </td><td style="text-align:left"> Initial position and window size. However if you do not define <code>NK_WINDOW_SCALABLE</code> or <code>NK_WINDOW_MOVABLE</code> you can set window position and size every frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">flags</strong> </td><td style="text-align:left"> Window flags defined in the <a href="#nk_panel_flags">nk_panel_flags</a> section with a number of different window behaviors </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if the window can be filled up with widgets from this point
until <code>nk_end</code> or <code>false(0)</code> otherwise for example if minimized

<p></p>
<a class="target" name="nk_begin_titled">&nbsp;</a><a class="target" name="toc1.7.4.6">&nbsp;</a><h4>nk_begin_titled</h4>
<p>

Extended window start with separated title and identifier to allow multiple
windows with same name but not title
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_begin_titled</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, struct nk_rect bounds, nk_flags flags)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Window identifier. Needs to be persistent over frames to identify the window </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Window title displayed inside header if flag <code>NK_WINDOW_TITLE</code> or either <code>NK_WINDOW_CLOSABLE</code> or <code>NK_WINDOW_MINIMIZED</code> was set </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">bounds</strong> </td><td style="text-align:left"> Initial position and window size. However if you do not define <code>NK_WINDOW_SCALABLE</code> or <code>NK_WINDOW_MOVABLE</code> you can set window position and size every frame </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">flags</strong> </td><td style="text-align:left"> Window flags defined in the <a href="#nk_panel_flags">nk_panel_flags</a> section with a number of different window behaviors </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if the window can be filled up with widgets from this point
until <code>nk_end</code> or <code>false(0)</code> otherwise for example if minimized

<p></p>
<a class="target" name="nk_end">&nbsp;</a><a class="target" name="toc1.7.4.7">&nbsp;</a><h4>nk_end</h4>
<p>

Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup.
All widget calls after this functions will result in asserts or no state changes
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_end</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_find">&nbsp;</a><a class="target" name="toc1.7.4.8">&nbsp;</a><h4>nk_window_find</h4>
<p>

Finds and returns a window from passed name
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_end</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Window identifier </td></tr>
</tbody></table></div>
Returns a <code>nk_window</code> struct pointing to the identified window or NULL if
no window with given name was found

<p></p>
<a class="target" name="nk_window_get_bounds">&nbsp;</a><a class="target" name="toc1.7.4.9">&nbsp;</a><h4>nk_window_get_bounds</h4>
<p>

Returns a rectangle with screen position and size of the currently processed window

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_rect <span class="hljs-title">nk_window_get_bounds</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns a <code>nk_rect</code> struct with window upper left window position and size

<p></p>
<a class="target" name="nk_window_get_bounds">&nbsp;</a><a class="target" name="toc1.7.4.10">&nbsp;</a><h4>nk_window_get_bounds</h4>
<p>

Returns the position of the currently processed window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_vec2 <span class="hljs-title">nk_window_get_position</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns a <code>nk_vec2</code> struct with window upper left position

<p></p>
<a class="target" name="nk_window_get_size">&nbsp;</a><a class="target" name="toc1.7.4.11">&nbsp;</a><h4>nk_window_get_size</h4>
<p>

Returns the size with width and height of the currently processed window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_vec2 <span class="hljs-title">nk_window_get_size</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns a <code>nk_vec2</code> struct with window width and height

<p></p>
<a class="target" name="nk_window_get_width">&nbsp;</a><a class="target" name="toc1.7.4.12">&nbsp;</a><h4>nk_window_get_width</h4>
<p>

Returns the width of the currently processed window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">nk_window_get_width</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns the current window width

<p></p>
<a class="target" name="nk_window_get_height">&nbsp;</a><a class="target" name="toc1.7.4.13">&nbsp;</a><h4>nk_window_get_height</h4>
<p>

Returns the height of the currently processed window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">nk_window_get_height</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns the current window height

<p></p>
<a class="target" name="nk_window_get_panel">&nbsp;</a><a class="target" name="toc1.7.4.14">&nbsp;</a><h4>nk_window_get_panel</h4>
<p>

Returns the underlying panel which contains all processing state of the current window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><p>

</p><div class="admonition warning">Do not keep the returned panel pointer around it is only valid until <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_panel* <span class="hljs-title">nk_window_get_panel</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns a pointer to window internal <code>nk_panel</code> state.

<p></p>
<a class="target" name="nk_window_get_content_region">&nbsp;</a><a class="target" name="toc1.7.4.15">&nbsp;</a><h4>nk_window_get_content_region</h4>
<p>

Returns the position and size of the currently visible and non-clipped space
inside the currently processed window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_rect <span class="hljs-title">nk_window_get_content_region</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns <code>nk_rect</code> struct with screen position and size (no scrollbar offset)
of the visible space inside the current window

<p></p>
<a class="target" name="nk_window_get_content_region_min">&nbsp;</a><a class="target" name="toc1.7.4.16">&nbsp;</a><h4>nk_window_get_content_region_min</h4>
<p>

Returns the upper left position of the currently visible and non-clipped
space inside the currently processed window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_vec2 <span class="hljs-title">nk_window_get_content_region_min</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
returns <code>nk_vec2</code> struct with  upper left screen position (no scrollbar offset)
of the visible space inside the current window

<p></p>
<a class="target" name="nk_window_get_content_region_max">&nbsp;</a><a class="target" name="toc1.7.4.17">&nbsp;</a><h4>nk_window_get_content_region_max</h4>
<p>

Returns the lower right screen position of the currently visible and
non-clipped space inside the currently processed window.

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_vec2 <span class="hljs-title">nk_window_get_content_region_max</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns <code>nk_vec2</code> struct with lower right screen position (no scrollbar offset)
of the visible space inside the current window

<p></p>
<a class="target" name="nk_window_get_content_region_size">&nbsp;</a><a class="target" name="toc1.7.4.18">&nbsp;</a><h4>nk_window_get_content_region_size</h4>
<p>

Returns the size of the currently visible and non-clipped space inside the
currently processed window

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_vec2 <span class="hljs-title">nk_window_get_content_region_size</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns <code>nk_vec2</code> struct with size the visible space inside the current window

<p></p>
<a class="target" name="nk_window_get_canvas">&nbsp;</a><a class="target" name="toc1.7.4.19">&nbsp;</a><h4>nk_window_get_canvas</h4>
<p>

Returns the draw command buffer. Can be used to draw custom widgets

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><p>

</p><div class="admonition warning">Do not keep the returned command buffer pointer around it is only valid until <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function">struct nk_command_buffer* <span class="hljs-title">nk_window_get_canvas</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns a pointer to window internal <code>nk_command_buffer</code> struct used as
drawing canvas. Can be used to do custom drawing.

<p></p>
<a class="target" name="nk_window_has_focus">&nbsp;</a><a class="target" name="toc1.7.4.20">&nbsp;</a><h4>nk_window_has_focus</h4>
<p>

Returns if the currently processed window is currently active

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_window_has_focus</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns <code>false(0)</code> if current window is not active or <code>true(1)</code> if it is

<p></p>
<a class="target" name="nk_window_is_hovered">&nbsp;</a><a class="target" name="toc1.7.4.21">&nbsp;</a><h4>nk_window_is_hovered</h4>
<p>

Return if the current window is being hovered

</p><p>

</p><div class="admonition warning">Only call this function between calls <code>nk_begin_xxx</code> and <code>nk_end</code></div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_window_is_hovered</span><span class="hljs-params">(struct nk_context *ctx)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if current window is hovered or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_window_is_collapsed">&nbsp;</a><a class="target" name="toc1.7.4.22">&nbsp;</a><h4>nk_window_is_collapsed</h4>
<p>

Returns if the window with given name is currently minimized/collapsed
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_window_is_collapsed</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of window you want to check if it is collapsed </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if current window is minimized and <code>false(0)</code> if window not
found or is not minimized

<p></p>
<a class="target" name="nk_window_is_closed">&nbsp;</a><a class="target" name="toc1.7.4.23">&nbsp;</a><h4>nk_window_is_closed</h4>
<p>

Returns if the window with given name was closed by calling <code>nk_close</code>
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_window_is_closed</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of window you want to check if it is closed </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if current window was closed or <code>false(0)</code> window not found or not closed

<p></p>
<a class="target" name="nk_window_is_hidden">&nbsp;</a><a class="target" name="toc1.7.4.24">&nbsp;</a><h4>nk_window_is_hidden</h4>
<p>

Returns if the window with given name is hidden
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_window_is_hidden</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of window you want to check if it is hidden </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if current window is hidden or <code>false(0)</code> window not found or visible

<p></p>
<a class="target" name="nk_window_is_active">&nbsp;</a><a class="target" name="toc1.7.4.25">&nbsp;</a><h4>nk_window_is_active</h4>
<p>

Same as nk_window_has_focus for some reason
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_window_is_active</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of window you want to check if it is active </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if current window is active or <code>false(0)</code> window not found or not active

<p></p>
<a class="target" name="nk_window_is_any_hovered">&nbsp;</a><a class="target" name="toc1.7.4.26">&nbsp;</a><h4>nk_window_is_any_hovered</h4>
<p>

Returns if the any window is being hovered
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_window_is_any_hovered</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if any window is hovered or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_item_is_any_active">&nbsp;</a><a class="target" name="toc1.7.4.27">&nbsp;</a><h4>nk_item_is_any_active</h4>
<p>

Returns if the any window is being hovered or any widget is currently active.
Can be used to decide if input should be processed by UI or your specific input handling.
Example could be UI and 3D camera to move inside a 3D space.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_item_is_any_active</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if any window is hovered or any item is active or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_window_set_bounds">&nbsp;</a><a class="target" name="toc1.7.4.28">&nbsp;</a><h4>nk_window_set_bounds</h4>
<p>

Updates position and size of window with passed in name
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_set_bounds</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, struct nk_rect bounds)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to modify both position and size </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">bounds</strong> </td><td style="text-align:left"> Must point to a <code>nk_rect</code> struct with the new position and size </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_set_position">&nbsp;</a><a class="target" name="toc1.7.4.29">&nbsp;</a><h4>nk_window_set_position</h4>
<p>

Updates position of window with passed name
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_set_position</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, struct nk_vec2 pos)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to modify both position </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">pos</strong> </td><td style="text-align:left"> Must point to a <code>nk_vec2</code> struct with the new position </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_set_size">&nbsp;</a><a class="target" name="toc1.7.4.30">&nbsp;</a><h4>nk_window_set_size</h4>
<p>

Updates size of window with passed in name
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_set_size</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, struct nk_vec2)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to modify both window size </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">size</strong> </td><td style="text-align:left"> Must point to a <code>nk_vec2</code> struct with new window size </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_set_focus">&nbsp;</a><a class="target" name="toc1.7.4.31">&nbsp;</a><h4>nk_window_set_focus</h4>
<p>

Sets the window with given name as active
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_set_focus</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to set focus on </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_close">&nbsp;</a><a class="target" name="toc1.7.4.32">&nbsp;</a><h4>nk_window_close</h4>
<p>

Closes a window and marks it for being freed at the end of the frame
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_close</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to close </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_collapse">&nbsp;</a><a class="target" name="toc1.7.4.33">&nbsp;</a><h4>nk_window_collapse</h4>
<p>

Updates collapse state of a window with given name
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_collapse</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">enum</span> nk_collapse_states state)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to close </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> value out of <a href="#nk_collapse_states">nk_collapse_states</a> section </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_collapse_if">&nbsp;</a><a class="target" name="toc1.7.4.34">&nbsp;</a><h4>nk_window_collapse_if</h4>
<p>

Updates collapse state of a window with given name if given condition is met
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_collapse_if</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">enum</span> nk_collapse_states, <span class="hljs-keyword">int</span> cond)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to either collapse or maximize </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> value out of <a href="#nk_collapse_states">nk_collapse_states</a> section the window should be put into </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">cond</strong> </td><td style="text-align:left"> condition that has to be met to actually commit the collapse state change </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_show">&nbsp;</a><a class="target" name="toc1.7.4.35">&nbsp;</a><h4>nk_window_show</h4>
<p>

updates visibility state of a window with given name
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_show</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">enum</span> nk_show_states)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to either collapse or maximize </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> state with either visible or hidden to modify the window with </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_window_show_if">&nbsp;</a><a class="target" name="toc1.7.4.36">&nbsp;</a><h4>nk_window_show_if</h4>
<p>

Updates visibility state of a window with given name if a given condition is met
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_window_show_if</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">enum</span> nk_show_states, <span class="hljs-keyword">int</span> cond)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> Identifier of the window to either hide or show </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> state with either visible or hidden to modify the window with </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">cond</strong> </td><td style="text-align:left"> condition that has to be met to actually commit the visbility state change </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="layouting">&nbsp;</a><a class="target" name="toc1.7.5">&nbsp;</a><h3>Layouting</h3>
<p>

Layouting in general describes placing widget inside a window with position and size.
While in this particular implementation there are five different APIs for layouting
each with different trade offs between control and ease of use. <br><br>
All layouting methods in this library are based around the concept of a row.
A row has a height the window content grows by and a number of columns and each
layouting method specifies how each widget is placed inside the row.
After a row has been allocated by calling a layouting functions and then
filled with widgets will advance an internal pointer over the allocated row. <br><br>
To actually define a layout you just call the appropriate layouting function
and each subsequent widget call will place the widget as specified. Important
here is that if you define more widgets then columns defined inside the layout
functions it will allocate the next row without you having to make another layouting <br><br>
call.
Biggest limitation with using all these APIs outside the <code>nk_layout_space_xxx</code> API
is that you have to define the row height for each. However the row height
often depends on the height of the font. <br><br>
To fix that internally nuklear uses a minimum row height that is set to the
height plus padding of currently active font and overwrites the row height
value if zero. <br><br>
If you manually want to change the minimum row height then
use nk_layout_set_min_row_height, and use nk_layout_reset_min_row_height to
reset it back to be derived from font height. <br><br>
Also if you change the font in nuklear it will automatically change the minimum
row height for you and. This means if you change the font but still want
a minimum row height smaller than the font you have to repush your value. <br><br>
For actually more advanced UI I would even recommend using the <code>nk_layout_space_xxx</code>
layouting method in combination with a cassowary constraint solver (there are
some versions on github with permissive license model) to take over all control over widget
layouting yourself. However for quick and dirty layouting using all the other layouting
functions should be fine.

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.5.1">&nbsp;</a><h4>Usage</h4>
<p>


</p><ol start="1">
<li class="number"> <strong class="underscore">nk_layout_row_dynamic</strong><br><br>
    The easiest layouting function is <code>nk_layout_row_dynamic</code>. It provides each
    widgets with same horizontal space inside the row and dynamically grows
    if the owning window grows in width. So the number of columns dictates
    the size of each widget dynamically by formula:
    <p></p><pre class="listing tilde"><code>widget_width = (window_width - padding - spacing) * (1/colum_count)</code></pre><p>
    Just like all other layouting APIs if you define more widget than columns this
    library will allocate a new row and keep all layouting parameters previously
    defined.
    </p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
    <span class="hljs-comment">// first row with height: 30 composed of two widgets</span>
    nk_layout_row_dynamic(&amp;ctx, <span class="hljs-number">30</span>, <span class="hljs-number">2</span>);
    nk_widget(...);
    nk_widget(...);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// second row with same parameter as defined above</span>
    nk_widget(...);
    nk_widget(...);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// third row uses 0 for height which will use auto layouting</span>
    nk_layout_row_dynamic(&amp;ctx, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
    nk_widget(...);
    nk_widget(...);
}
nk_end(...);</code></pre><p>
</p></li>
<li class="number"> <strong class="underscore">nk_layout_row_static</strong><br><br>
    Another easy layouting function is <code>nk_layout_row_static</code>. It provides each
    widget with same horizontal pixel width inside the row and does not grow
    if the owning window scales smaller or bigger.
    <p></p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
    <span class="hljs-comment">// first row with height: 30 composed of two widgets with width: 80</span>
    nk_layout_row_static(&amp;ctx, <span class="hljs-number">30</span>, <span class="hljs-number">80</span>, <span class="hljs-number">2</span>);
    nk_widget(...);
    nk_widget(...);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// second row with same parameter as defined above</span>
    nk_widget(...);
    nk_widget(...);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// third row uses 0 for height which will use auto layouting</span>
    nk_layout_row_static(&amp;ctx, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">2</span>);
    nk_widget(...);
    nk_widget(...);
}
nk_end(...);</code></pre><p>
</p></li>
<li class="number"> <strong class="underscore">nk_layout_row_xxx</strong><br><br>
    A little bit more advanced layouting API are functions <code>nk_layout_row_begin</code>,
    <code>nk_layout_row_push</code> and <code>nk_layout_row_end</code>. They allow to directly
    specify each column pixel or window ratio in a row. It supports either
    directly setting per column pixel width or widget window ratio but not
    both. Furthermore it is a immediate mode API so each value is directly
    pushed before calling a widget. Therefore the layout is not automatically
    repeating like the last two layouting functions.
    <p></p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
    <span class="hljs-comment">// first row with height: 25 composed of two widgets with width 60 and 40</span>
    nk_layout_row_begin(ctx, NK_STATIC, <span class="hljs-number">25</span>, <span class="hljs-number">2</span>);
    nk_layout_row_push(ctx, <span class="hljs-number">60</span>);
    nk_widget(...);
    nk_layout_row_push(ctx, <span class="hljs-number">40</span>);
    nk_widget(...);
    nk_layout_row_end(ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// second row with height: 25 composed of two widgets with window ratio 0.25 and 0.75</span>
    nk_layout_row_begin(ctx, NK_DYNAMIC, <span class="hljs-number">25</span>, <span class="hljs-number">2</span>);
    nk_layout_row_push(ctx, <span class="hljs-number">0.25f</span>);
    nk_widget(...);
    nk_layout_row_push(ctx, <span class="hljs-number">0.75f</span>);
    nk_widget(...);
    nk_layout_row_end(ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// third row with auto generated height: composed of two widgets with window ratio 0.25 and 0.75</span>
    nk_layout_row_begin(ctx, NK_DYNAMIC, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
    nk_layout_row_push(ctx, <span class="hljs-number">0.25f</span>);
    nk_widget(...);
    nk_layout_row_push(ctx, <span class="hljs-number">0.75f</span>);
    nk_widget(...);
    nk_layout_row_end(ctx);
}
nk_end(...);</code></pre><p>
</p></li>
<li class="number"> <strong class="underscore">nk_layout_row</strong><br><br>
    The array counterpart to API nk_layout_row_xxx is the single nk_layout_row
    functions. Instead of pushing either pixel or window ratio for every widget
    it allows to define it by array. The trade of for less control is that
    <code>nk_layout_row</code> is automatically repeating. Otherwise the behavior is the
    same.
    <p></p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
    <span class="hljs-comment">// two rows with height: 30 composed of two widgets with width 60 and 40</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> size[] = {<span class="hljs-number">60</span>,<span class="hljs-number">40</span>};
    nk_layout_row(ctx, NK_STATIC, <span class="hljs-number">30</span>, <span class="hljs-number">2</span>, ratio);
    nk_widget(...);
    nk_widget(...);
    nk_widget(...);
    nk_widget(...);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// two rows with height: 30 composed of two widgets with window ratio 0.25 and 0.75</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> ratio[] = {<span class="hljs-number">0.25</span>, <span class="hljs-number">0.75</span>};
    nk_layout_row(ctx, NK_DYNAMIC, <span class="hljs-number">30</span>, <span class="hljs-number">2</span>, ratio);
    nk_widget(...);
    nk_widget(...);
    nk_widget(...);
    nk_widget(...);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// two rows with auto generated height composed of two widgets with window ratio 0.25 and 0.75</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> ratio[] = {<span class="hljs-number">0.25</span>, <span class="hljs-number">0.75</span>};
    nk_layout_row(ctx, NK_DYNAMIC, <span class="hljs-number">30</span>, <span class="hljs-number">2</span>, ratio);
    nk_widget(...);
    nk_widget(...);
    nk_widget(...);
    nk_widget(...);
}
nk_end(...);</code></pre><p>
</p></li>
<li class="number"> <strong class="underscore">nk_layout_row_template_xxx</strong><br><br>
    The most complex and second most flexible API is a simplified flexbox version without
    line wrapping and weights for dynamic widgets. It is an immediate mode API but
    unlike <code>nk_layout_row_xxx</code> it has auto repeat behavior and needs to be called
    before calling the templated widgets.
    The row template layout has three different per widget size specifier. The first
    one is the <code>nk_layout_row_template_push_static</code>  with fixed widget pixel width.
    They do not grow if the row grows and will always stay the same.
    The second size specifier is <code>nk_layout_row_template_push_variable</code>
    which defines a minimum widget size but it also can grow if more space is available
    not taken by other widgets.
    Finally there are dynamic widgets with <code>nk_layout_row_template_push_dynamic</code>
    which are completely flexible and unlike variable widgets can even shrink
    to zero if not enough space is provided.
    <p></p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
    <span class="hljs-comment">// two rows with height: 30 composed of three widgets</span>
    nk_layout_row_template_begin(ctx, <span class="hljs-number">30</span>);
    nk_layout_row_template_push_dynamic(ctx);
    nk_layout_row_template_push_variable(ctx, <span class="hljs-number">80</span>);
    nk_layout_row_template_push_static(ctx, <span class="hljs-number">80</span>);
    nk_layout_row_template_end(ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// first row</span>
    nk_widget(...); <span class="hljs-comment">// dynamic widget can go to zero if not enough space</span>
    nk_widget(...); <span class="hljs-comment">// variable widget with min 80 pixel but can grow bigger if enough space</span>
    nk_widget(...); <span class="hljs-comment">// static widget with fixed 80 pixel width</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// second row same layout</span>
    nk_widget(...);
    nk_widget(...);
    nk_widget(...);
}
nk_end(...);</code></pre><p>
</p></li>
<li class="number"> <strong class="underscore">nk_layout_space_xxx</strong><br><br>
    Finally the most flexible API directly allows you to place widgets inside the
    window. The space layout API is an immediate mode API which does not support
    row auto repeat and directly sets position and size of a widget. Position
    and size hereby can be either specified as ratio of allocated space or
    allocated space local position and pixel size. Since this API is quite
    powerful there are a number of utility functions to get the available space
    and convert between local allocated space and screen space.
    <p></p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
    <span class="hljs-comment">// static row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)</span>
    nk_layout_space_begin(ctx, NK_STATIC, <span class="hljs-number">500</span>, INT_MAX);
    nk_layout_space_push(ctx, nk_rect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,<span class="hljs-number">200</span>));
    nk_widget(...);
    nk_layout_space_push(ctx, nk_rect(<span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>));
    nk_widget(...);
    nk_layout_space_end(ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// dynamic row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)</span>
    nk_layout_space_begin(ctx, NK_DYNAMIC, <span class="hljs-number">500</span>, INT_MAX);
    nk_layout_space_push(ctx, nk_rect(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>));
    nk_widget(...);
    nk_layout_space_push(ctx, nk_rect(<span class="hljs-number">0.7</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>));
    nk_widget(...);
}
nk_end(...);</code></pre><p></p></li></ol>

<p></p>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.5.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> nk_layout_set_min_row_height </td><td style="text-align:left"> Set the currently used minimum row height to a specified value </td></tr>
<tr><td style="text-align:left"> nk_layout_reset_min_row_height </td><td style="text-align:left"> Resets the currently used minimum row height to font height </td></tr>
<tr><td style="text-align:left"> nk_layout_widget_bounds </td><td style="text-align:left"> Calculates current width a static layout row can fit inside a window </td></tr>
<tr><td style="text-align:left"> nk_layout_ratio_from_pixel </td><td style="text-align:left"> Utility functions to calculate window ratio from pixel size </td></tr>
<tr><td style="text-align:left"> nk_layout_row_dynamic </td><td style="text-align:left"> Current layout is divided into n same sized growing columns </td></tr>
<tr><td style="text-align:left"> nk_layout_row_static </td><td style="text-align:left"> Current layout is divided into n same fixed sized columns </td></tr>
<tr><td style="text-align:left"> nk_layout_row_begin </td><td style="text-align:left"> Starts a new row with given height and number of columns </td></tr>
<tr><td style="text-align:left"> nk_layout_row_push </td><td style="text-align:left"> Pushes another column with given size or window ratio </td></tr>
<tr><td style="text-align:left"> nk_layout_row_end </td><td style="text-align:left"> Finished previously started row </td></tr>
<tr><td style="text-align:left"> nk_layout_row </td><td style="text-align:left"> Specifies row columns in array as either window ratio or size </td></tr>
<tr><td style="text-align:left"> nk_layout_row_template_begin </td><td style="text-align:left"> Begins the row template declaration </td></tr>
<tr><td style="text-align:left"> nk_layout_row_template_push_dynamic </td><td style="text-align:left"> Adds a dynamic column that dynamically grows and can go to zero if not enough space </td></tr>
<tr><td style="text-align:left"> nk_layout_row_template_push_variable </td><td style="text-align:left"> Adds a variable column that dynamically grows but does not shrink below specified pixel width </td></tr>
<tr><td style="text-align:left"> nk_layout_row_template_push_static </td><td style="text-align:left"> Adds a static column that does not grow and will always have the same size </td></tr>
<tr><td style="text-align:left"> nk_layout_row_template_end </td><td style="text-align:left"> Marks the end of the row template </td></tr>
<tr><td style="text-align:left"> nk_layout_space_begin </td><td style="text-align:left"> Begins a new layouting space that allows to specify each widgets position and size </td></tr>
<tr><td style="text-align:left"> nk_layout_space_push </td><td style="text-align:left"> Pushes position and size of the next widget in own coordinate space either as pixel or ratio </td></tr>
<tr><td style="text-align:left"> nk_layout_space_end </td><td style="text-align:left"> Marks the end of the layouting space </td></tr>
<tr><td style="text-align:left"> nk_layout_space_bounds </td><td style="text-align:left"> Callable after nk_layout_space_begin and returns total space allocated </td></tr>
<tr><td style="text-align:left"> nk_layout_space_to_screen </td><td style="text-align:left"> Converts vector from nk_layout_space coordinate space into screen space </td></tr>
<tr><td style="text-align:left"> nk_layout_space_to_local </td><td style="text-align:left"> Converts vector from screen space into nk_layout_space coordinates </td></tr>
<tr><td style="text-align:left"> nk_layout_space_rect_to_screen </td><td style="text-align:left"> Converts rectangle from nk_layout_space coordinate space into screen space </td></tr>
<tr><td style="text-align:left"> nk_layout_space_rect_to_local </td><td style="text-align:left"> Converts rectangle from screen space into nk_layout_space coordinates </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_set_min_row_height">&nbsp;</a><a class="target" name="toc1.7.5.3">&nbsp;</a><h4>nk_layout_set_min_row_height</h4>
<p>

Sets the currently used minimum row height.

</p><p>

</p><div class="admonition warning">The passed height needs to include both your preferred row height
    as well as padding. No internal padding is added.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_set_min_row_height</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">float</span> height)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> New minimum row height to be used for auto generating the row height </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_reset_min_row_height">&nbsp;</a><a class="target" name="toc1.7.5.4">&nbsp;</a><h4>nk_layout_reset_min_row_height</h4>
<p>

Reset the currently used minimum row height back to <code>font_height + text_padding + padding</code>
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_reset_min_row_height</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_widget_bounds">&nbsp;</a><a class="target" name="toc1.7.5.5">&nbsp;</a><h4>nk_layout_widget_bounds</h4>
<p>

Returns the width of the next row allocate by one of the layouting functions
</p><pre class="listing tilde"><code><span class="hljs-function">struct nk_rect <span class="hljs-title">nk_layout_widget_bounds</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
</tbody></table></div>
Return <code>nk_rect</code> with both position and size of the next row

<p></p>
<a class="target" name="nk_layout_ratio_from_pixel">&nbsp;</a><a class="target" name="toc1.7.5.6">&nbsp;</a><h4>nk_layout_ratio_from_pixel</h4>
<p>

Utility functions to calculate window ratio from pixel size
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">nk_layout_ratio_from_pixel</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">float</span> pixel_width)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">pixel</strong> </td><td style="text-align:left"> Pixel_width to convert to window ratio </td></tr>
</tbody></table></div>
Returns <code>nk_rect</code> with both position and size of the next row

<p></p>
<a class="target" name="nk_layout_row_dynamic">&nbsp;</a><a class="target" name="toc1.7.5.7">&nbsp;</a><h4>nk_layout_row_dynamic</h4>
<p>

Sets current row layout to share horizontal space
between @cols number of widgets evenly. Once called all subsequent widget
calls greater than @cols will allocate a new row with same layout.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_dynamic</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> cols)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> Holds height of each widget in row or zero for auto layouting </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">columns</strong> </td><td style="text-align:left"> Number of widget inside row </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_dynamic">&nbsp;</a><a class="target" name="toc1.7.5.8">&nbsp;</a><h4>nk_layout_row_dynamic</h4>
<p>

Sets current row layout to fill @cols number of widgets
in row with same @item_width horizontal size. Once called all subsequent widget
calls greater than @cols will allocate a new row with same layout.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_static</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> item_width, <span class="hljs-keyword">int</span> cols)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> Holds height of each widget in row or zero for auto layouting </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">width</strong> </td><td style="text-align:left"> Holds pixel width of each widget in the row </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">columns</strong> </td><td style="text-align:left"> Number of widget inside row </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_begin">&nbsp;</a><a class="target" name="toc1.7.5.9">&nbsp;</a><h4>nk_layout_row_begin</h4>
<p>

Starts a new dynamic or fixed row with given height and columns.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_begin</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">enum</span> nk_layout_format fmt, <span class="hljs-keyword">float</span> row_height, <span class="hljs-keyword">int</span> cols)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">fmt</strong> </td><td style="text-align:left"> either <code>NK_DYNAMIC</code> for window ratio or <code>NK_STATIC</code> for fixed size columns </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> holds height of each widget in row or zero for auto layouting </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">columns</strong> </td><td style="text-align:left"> Number of widget inside row </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_push">&nbsp;</a><a class="target" name="toc1.7.5.10">&nbsp;</a><h4>nk_layout_row_push</h4>
<p>

Specifies either window ratio or width of a single column
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_push</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">float</span> value)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">value</strong> </td><td style="text-align:left"> either a window ratio or fixed width depending on @fmt in previous <code>nk_layout_row_begin</code> call </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_end">&nbsp;</a><a class="target" name="toc1.7.5.11">&nbsp;</a><h4>nk_layout_row_end</h4>
<p>

Finished previously started row
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_end</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row">&nbsp;</a><a class="target" name="toc1.7.5.12">&nbsp;</a><h4>nk_layout_row</h4>
<p>

Specifies row columns in array as either window ratio or size
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">enum</span> nk_layout_format, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> *ratio)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">fmt</strong> </td><td style="text-align:left"> Either <code>NK_DYNAMIC</code> for window ratio or <code>NK_STATIC</code> for fixed size columns </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> Holds height of each widget in row or zero for auto layouting </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">columns</strong> </td><td style="text-align:left"> Number of widget inside row </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_template_begin">&nbsp;</a><a class="target" name="toc1.7.5.13">&nbsp;</a><h4>nk_layout_row_template_begin</h4>
<p>

Begins the row template declaration
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_template_begin</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">float</span> row_height)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> Holds height of each widget in row or zero for auto layouting </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_template_push_dynamic">&nbsp;</a><a class="target" name="toc1.7.5.14">&nbsp;</a><h4>nk_layout_row_template_push_dynamic</h4>
<p>

Adds a dynamic column that dynamically grows and can go to zero if not enough space
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_template_push_dynamic</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> Holds height of each widget in row or zero for auto layouting </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_template_push_variable">&nbsp;</a><a class="target" name="toc1.7.5.15">&nbsp;</a><h4>nk_layout_row_template_push_variable</h4>
<p>

Adds a variable column that dynamically grows but does not shrink below specified pixel width
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_template_push_variable</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">float</span> min_width)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">width</strong> </td><td style="text-align:left"> Holds the minimum pixel width the next column must always be </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_template_push_static">&nbsp;</a><a class="target" name="toc1.7.5.16">&nbsp;</a><h4>nk_layout_row_template_push_static</h4>
<p>

Adds a static column that does not grow and will always have the same size
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_template_push_static</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">float</span> width)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">width</strong> </td><td style="text-align:left"> Holds the absolute pixel width value the next column must be </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_row_template_end">&nbsp;</a><a class="target" name="toc1.7.5.17">&nbsp;</a><h4>nk_layout_row_template_end</h4>
<p>

Marks the end of the row template
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_row_template_end</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_space_begin">&nbsp;</a><a class="target" name="toc1.7.5.18">&nbsp;</a><h4>nk_layout_space_begin</h4>
<p>

Begins a new layouting space that allows to specify each widgets position and size.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_space_begin</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">enum</span> nk_layout_format, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> widget_count)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_begin_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">fmt</strong> </td><td style="text-align:left"> Either <code>NK_DYNAMIC</code> for window ratio or <code>NK_STATIC</code> for fixed size columns </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">height</strong> </td><td style="text-align:left"> Holds height of each widget in row or zero for auto layouting </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">columns</strong> </td><td style="text-align:left"> Number of widgets inside row </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_space_push">&nbsp;</a><a class="target" name="toc1.7.5.19">&nbsp;</a><h4>nk_layout_space_push</h4>
<p>

Pushes position and size of the next widget in own coordinate space either as pixel or ratio
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_space_push</span><span class="hljs-params">(struct nk_context *ctx, struct nk_rect bounds)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_layout_space_begin</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">bounds</strong> </td><td style="text-align:left"> Position and size in laoyut space local coordinates </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_space_end">&nbsp;</a><a class="target" name="toc1.7.5.20">&nbsp;</a><h4>nk_layout_space_end</h4>
<p>

Marks the end of the layout space
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_layout_space_end</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_layout_space_begin</code> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_layout_space_bounds">&nbsp;</a><a class="target" name="toc1.7.5.21">&nbsp;</a><h4>nk_layout_space_bounds</h4>
<p>

Utility function to calculate total space allocated for <code>nk_layout_space</code>
</p><pre class="listing tilde"><code><span class="hljs-function">struct nk_rect <span class="hljs-title">nk_layout_space_bounds</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_layout_space_begin</code> </td></tr>
</tbody></table></div>
Returns <code>nk_rect</code> holding the total space allocated

<p></p>
<a class="target" name="nk_layout_space_to_screen">&nbsp;</a><a class="target" name="toc1.7.5.22">&nbsp;</a><h4>nk_layout_space_to_screen</h4>
<p>

Converts vector from nk_layout_space coordinate space into screen space
</p><pre class="listing tilde"><code><span class="hljs-function">struct nk_vec2 <span class="hljs-title">nk_layout_space_to_screen</span><span class="hljs-params">(struct nk_context*, struct nk_vec2)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_layout_space_begin</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">vec</strong> </td><td style="text-align:left"> Position to convert from layout space into screen coordinate space </td></tr>
</tbody></table></div>
Returns transformed <code>nk_vec2</code> in screen space coordinates

<p></p>
<a class="target" name="nk_layout_space_to_screen">&nbsp;</a><a class="target" name="toc1.7.5.23">&nbsp;</a><h4>nk_layout_space_to_screen</h4>
<p>

Converts vector from layout space into screen space
</p><pre class="listing tilde"><code><span class="hljs-function">struct nk_vec2 <span class="hljs-title">nk_layout_space_to_local</span><span class="hljs-params">(struct nk_context*, struct nk_vec2)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_layout_space_begin</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">vec</strong> </td><td style="text-align:left"> Position to convert from screen space into layout coordinate space </td></tr>
</tbody></table></div>
Returns transformed <code>nk_vec2</code> in layout space coordinates

<p></p>
<a class="target" name="nk_layout_space_rect_to_screen">&nbsp;</a><a class="target" name="toc1.7.5.24">&nbsp;</a><h4>nk_layout_space_rect_to_screen</h4>
<p>

Converts rectangle from screen space into layout space
</p><pre class="listing tilde"><code><span class="hljs-function">struct nk_rect <span class="hljs-title">nk_layout_space_rect_to_screen</span><span class="hljs-params">(struct nk_context*, struct nk_rect)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_layout_space_begin</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">bounds</strong> </td><td style="text-align:left"> Rectangle to convert from layout space into screen space </td></tr>
</tbody></table></div>
Returns transformed <code>nk_rect</code> in screen space coordinates

<p></p>
<a class="target" name="nk_layout_space_rect_to_local">&nbsp;</a><a class="target" name="toc1.7.5.25">&nbsp;</a><h4>nk_layout_space_rect_to_local</h4>
<p>

Converts rectangle from layout space into screen space
</p><pre class="listing tilde"><code><span class="hljs-function">struct nk_rect <span class="hljs-title">nk_layout_space_rect_to_local</span><span class="hljs-params">(struct nk_context*, struct nk_rect)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after call <code>nk_layout_space_begin</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">bounds</strong> </td><td style="text-align:left"> Rectangle to convert from layout space into screen space </td></tr>
</tbody></table></div>
Returns transformed <code>nk_rect</code> in layout space coordinates

<p></p>
<a class="target" name="groups">&nbsp;</a><a class="target" name="toc1.7.6">&nbsp;</a><h3>Groups</h3>
<p>

Groups are basically windows inside windows. They allow to subdivide space
in a window to layout widgets as a group. Almost all more complex widget
layouting requirements can be solved using groups and basic layouting
fuctionality. Groups just like windows are identified by an unique name and
internally keep track of scrollbar offsets by default. However additional
versions are provided to directly manage the scrollbar.

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.6.1">&nbsp;</a><h4>Usage</h4>
<p>

To create a group you have to call one of the three <code>nk_group_begin_xxx</code>
functions to start group declarations and <code>nk_group_end</code> at the end. Furthermore it
is required to check the return value of <code>nk_group_begin_xxx</code> and only process
widgets inside the window if the value is not 0.
Nesting groups is possible and even encouraged since many layouting schemes
can only be achieved by nesting. Groups, unlike windows, need <code>nk_group_end</code>
to be only called if the corosponding <code>nk_group_begin_xxx</code> call does not return 0:
</p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_group_begin_xxx(ctx, ...) {
    <span class="hljs-comment">// [... widgets ...]</span>
    nk_group_end(ctx);
}</code></pre><p>
In the grand concept groups can be called after starting a window
with <code>nk_begin_xxx</code> and before calling <code>nk_end</code>:
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_xxx(&amp;ctx, ...);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// Input</span>
    Event evt;
    nk_input_begin(&amp;ctx);
    <span class="hljs-keyword">while</span> (GetEvent(&amp;evt)) {
        <span class="hljs-keyword">if</span> (evt.type == MOUSE_MOVE)
            nk_input_motion(&amp;ctx, evt.motion.x, evt.motion.y);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evt.type == [...]) {
            nk_input_xxx(...);
        }
    }
    nk_input_end(&amp;ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Window</span>
    <span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
        <span class="hljs-comment">// [...widgets...]</span>
        nk_layout_row_dynamic(...);
        <span class="hljs-keyword">if</span> (nk_group_begin_xxx(ctx, ...) {
            <span class="hljs-comment">//[... widgets ...]</span>
            nk_group_end(ctx);
        }
    }
    nk_end(ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Draw</span>
    <span class="hljs-keyword">const</span> struct nk_command *cmd = <span class="hljs-number">0</span>;
    nk_foreach(cmd, &amp;ctx) {
    <span class="hljs-keyword">switch</span> (cmd-&gt;type) {
    <span class="hljs-keyword">case</span> NK_COMMAND_LINE:
        your_draw_line_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> NK_COMMAND_RECT
        your_draw_rect_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> ...:
        <span class="hljs-comment">// [...]</span>
    }
}
nk_free(&amp;ctx);</code></pre>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.6.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> nk_group_begin </td><td style="text-align:left"> Start a new group with internal scrollbar handling </td></tr>
<tr><td style="text-align:left"> nk_group_begin_titled </td><td style="text-align:left"> Start a new group with separeted name and title and internal scrollbar handling </td></tr>
<tr><td style="text-align:left"> nk_group_end </td><td style="text-align:left"> Ends a group. Should only be called if nk_group_begin returned non-zero </td></tr>
<tr><td style="text-align:left"> nk_group_scrolled_offset_begin </td><td style="text-align:left"> Start a new group with manual separated handling of scrollbar x- and y-offset </td></tr>
<tr><td style="text-align:left"> nk_group_scrolled_begin </td><td style="text-align:left"> Start a new group with manual scrollbar handling </td></tr>
<tr><td style="text-align:left"> nk_group_scrolled_end </td><td style="text-align:left"> Ends a group with manual scrollbar handling. Should only be called if nk_group_begin returned non-zero </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_group_begin">&nbsp;</a><a class="target" name="toc1.7.6.3">&nbsp;</a><h4>nk_group_begin</h4>
<p>

Starts a new widget group. Requires a previous layouting function to specify a pos/size.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_group_begin</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, nk_flags)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Must be an unique identifier for this group that is also used for the group header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">flags</strong> </td><td style="text-align:left"> Window flags defined in the <a href="#nk_panel_flags">nk_panel_flags</a> section with a number of different group behaviors </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_group_begin_titled">&nbsp;</a><a class="target" name="toc1.7.6.4">&nbsp;</a><h4>nk_group_begin_titled</h4>
<p>

Starts a new widget group. Requires a previous layouting function to specify a pos/size.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_group_begin_titled</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, nk_flags)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">id</strong> </td><td style="text-align:left"> Must be an unique identifier for this group </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Group header title </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">flags</strong> </td><td style="text-align:left"> Window flags defined in the <a href="#nk_panel_flags">nk_panel_flags</a> section with a number of different group behaviors </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_group_end">&nbsp;</a><a class="target" name="toc1.7.6.5">&nbsp;</a><h4>nk_group_end</h4>
<p>

Ends a widget group
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_group_end</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_group_scrolled_offset_begin">&nbsp;</a><a class="target" name="toc1.7.6.6">&nbsp;</a><h4>nk_group_scrolled_offset_begin</h4>
<p>

starts a new widget group. requires a previous layouting function to specify
a size. Does not keep track of scrollbar.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_group_scrolled_offset_begin</span><span class="hljs-params">(struct nk_context*, nk_uint *x_offset, nk_uint *y_offset, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, nk_flags flags)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">x_offset</strong> </td><td style="text-align:left"> Scrollbar x-offset to offset all widgets inside the group horizontally. </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">y_offset</strong> </td><td style="text-align:left"> Scrollbar y-offset to offset all widgets inside the group vertically </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Window unique group title used to both identify and display in the group header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">flags</strong> </td><td style="text-align:left"> Window flags from the <a href="#nk_panel_flags">nk_panel_flags</a> section </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_group_scrolled_begin">&nbsp;</a><a class="target" name="toc1.7.6.7">&nbsp;</a><h4>nk_group_scrolled_begin</h4>
<p>

Starts a new widget group. requires a previous
layouting function to specify a size. Does not keep track of scrollbar.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_group_scrolled_begin</span><span class="hljs-params">(struct nk_context*, struct nk_scroll *off, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, nk_flags)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">off</strong> </td><td style="text-align:left"> Both x- and y- scroll offset. Allows for manual scrollbar control </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Window unique group title used to both identify and display in the group header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">flags</strong> </td><td style="text-align:left"> Window flags from <a href="#nk_panel_flags">nk_panel_flags</a> section </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_group_scrolled_end">&nbsp;</a><a class="target" name="toc1.7.6.8">&nbsp;</a><h4>nk_group_scrolled_end</h4>
<p>

Ends a widget group after calling nk_group_scrolled_offset_begin or nk_group_scrolled_begin.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_group_scrolled_end</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="tree">&nbsp;</a><a class="target" name="toc1.7.7">&nbsp;</a><h3>Tree</h3>
<p>

Trees represent two different concept. First the concept of a collapsable
UI section that can be either in a hidden or visibile state. They allow the UI
user to selectively minimize the current set of visible UI to comprehend.
The second concept are tree widgets for visual UI representation of trees.<br><br>
Trees thereby can be nested for tree representations and multiple nested
collapsable UI sections. All trees are started by calling of the
<code>nk_tree_xxx_push_tree</code> functions and ended by calling one of the
<code>nk_tree_xxx_pop_xxx()</code> functions. Each starting functions takes a title label
and optionally an image to be displayed and the initial collapse state from
the <a href="#nk_collapse_states">nk_collapse_states</a> section.<br><br>
The runtime state of the tree is either stored outside the library by the caller
or inside which requires a unique ID. The unique ID can either be generated
automatically from <code>__FILE__</code> and <code>__LINE__</code> with function <code>nk_tree_push</code>,
by <code>__FILE__</code> and a user provided ID generated for example by loop index with
function <code>nk_tree_push_id</code> or completely provided from outside by user with
function <code>nk_tree_push_hashed</code>.

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.7.1">&nbsp;</a><h4>Usage</h4>
<p>

To create a tree you have to call one of the seven <code>nk_tree_xxx_push_xxx</code>
functions to start a collapsable UI section and <code>nk_tree_xxx_pop</code> to mark the
end.
Each starting function will either return <code>false(0)</code> if the tree is collapsed
or hidden and therefore does not need to be filled with content or <code>true(1)</code>
if visible and required to be filled.

</p><p>

</p><div class="admonition note">The tree header does not require and layouting function and instead
    calculates a auto height based on the currently used font size</div>

<p></p><p>

The tree ending functions only need to be called if the tree content is
actually visible. So make sure the tree push function is guarded by <code>if</code>
and the pop call is only taken if the tree is visible.
</p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (nk_tree_push(ctx, NK_TREE_TAB, <span class="hljs-string">"Tree"</span>, NK_MINIMIZED)) {
    nk_layout_row_dynamic(...);
    nk_widget(...);
    nk_tree_pop(ctx);
}</code></pre>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.7.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> nk_tree_push </td><td style="text-align:left"> Start a collapsable UI section with internal state management </td></tr>
<tr><td style="text-align:left"> nk_tree_push_id </td><td style="text-align:left"> Start a collapsable UI section with internal state management callable in a look </td></tr>
<tr><td style="text-align:left"> nk_tree_push_hashed </td><td style="text-align:left"> Start a collapsable UI section with internal state management with full control over internal unique ID use to store state </td></tr>
<tr><td style="text-align:left"> nk_tree_image_push </td><td style="text-align:left"> Start a collapsable UI section with image and label header </td></tr>
<tr><td style="text-align:left"> nk_tree_image_push_id </td><td style="text-align:left"> Start a collapsable UI section with image and label header and internal state management callable in a look </td></tr>
<tr><td style="text-align:left"> nk_tree_image_push_hashed </td><td style="text-align:left">
 Start a collapsable UI section with image and label header and internal
 state management with full control over internal unique ID use to store
 state </td></tr>
<tr><td style="text-align:left"> nk_tree_pop </td><td style="text-align:left"> Ends a collapsable UI section </td></tr>
<tr><td style="text-align:left"> nk_tree_state_push </td><td style="text-align:left"> Start a collapsable UI section with external state management </td></tr>
<tr><td style="text-align:left"> nk_tree_state_image_push </td><td style="text-align:left"> Start a collapsable UI section with image and label header and external state management </td></tr>
<tr><td style="text-align:left"> nk_tree_state_pop </td><td style="text-align:left"> Ends a collapsabale UI section </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_tree_type">&nbsp;</a><a class="target" name="toc1.7.7.3">&nbsp;</a><h4>nk_tree_type</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Flag </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> NK_TREE_NODE </td><td style="text-align:left"> Highlighted tree header to mark a collapsable UI section </td></tr>
<tr><td style="text-align:left"> NK_TREE_TAB </td><td style="text-align:left"> Non-highighted tree header closer to tree representations </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_tree_push">&nbsp;</a><a class="target" name="toc1.7.7.4">&nbsp;</a><h4>nk_tree_push</h4>
<p>

Starts a collapsable UI section with internal state management

</p><p>

</p><div class="admonition warning">To keep track of the runtime tree collapsable state this function uses
    defines <code>__FILE__</code> and <code>__LINE__</code> to generate a unique ID. If you want
    to call this function in a loop please use <code>nk_tree_push_id</code> or
    <code>nk_tree_push_hashed</code> instead.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nk_tree_push(ctx, type, title, state)</span></code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Initial tree state value out of nk_collapse_states </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_push_id">&nbsp;</a><a class="target" name="toc1.7.7.5">&nbsp;</a><h4>nk_tree_push_id</h4>
<p>

Starts a collapsable UI section with internal state management callable in a look
</p><pre class="listing tilde"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nk_tree_push_id(ctx, type, title, state, id)</span></code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Initial tree state value out of nk_collapse_states </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">id</strong> </td><td style="text-align:left"> Loop counter index if this function is called in a loop </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_push_hashed">&nbsp;</a><a class="target" name="toc1.7.7.6">&nbsp;</a><h4>nk_tree_push_hashed</h4>
<p>

Start a collapsable UI section with internal state management with full
control over internal unique ID used to store state
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_tree_push_hashed</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">enum</span> nk_tree_type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, <span class="hljs-keyword">enum</span> nk_collapse_states initial_state, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *hash, <span class="hljs-keyword">int</span> len,<span class="hljs-keyword">int</span> seed)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Initial tree state value out of nk_collapse_states </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">hash</strong> </td><td style="text-align:left"> Memory block or string to generate the ID from </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">len</strong> </td><td style="text-align:left"> Size of passed memory block or string in <strong class="underscore">hash</strong> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">seed</strong> </td><td style="text-align:left"> Seeding value if this function is called in a loop or default to <code>0</code> </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_image_push">&nbsp;</a><a class="target" name="toc1.7.7.7">&nbsp;</a><h4>nk_tree_image_push</h4>
<p>

Start a collapsable UI section with image and label header

</p><p>

</p><div class="admonition warning">To keep track of the runtime tree collapsable state this function uses
    defines <code>__FILE__</code> and <code>__LINE__</code> to generate a unique ID. If you want
    to call this function in a loop please use <code>nk_tree_image_push_id</code> or
    <code>nk_tree_image_push_hashed</code> instead.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nk_tree_image_push(ctx, type, img, title, state)</span></code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">img</strong> </td><td style="text-align:left"> Image to display inside the header on the left of the label </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Initial tree state value out of nk_collapse_states </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_image_push_id">&nbsp;</a><a class="target" name="toc1.7.7.8">&nbsp;</a><h4>nk_tree_image_push_id</h4>
<p>

Start a collapsable UI section with image and label header and internal state
management callable in a look
</p><pre class="listing tilde"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nk_tree_image_push_id(ctx, type, img, title, state, id)</span></code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">img</strong> </td><td style="text-align:left"> Image to display inside the header on the left of the label </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Initial tree state value out of nk_collapse_states </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">id</strong> </td><td style="text-align:left"> Loop counter index if this function is called in a loop </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_image_push_hashed">&nbsp;</a><a class="target" name="toc1.7.7.9">&nbsp;</a><h4>nk_tree_image_push_hashed</h4>
<p>

Start a collapsable UI section with internal state management with full
control over internal unique ID used to store state
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_tree_image_push_hashed</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">enum</span> nk_tree_type, struct nk_image, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, <span class="hljs-keyword">enum</span> nk_collapse_states initial_state, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *hash, <span class="hljs-keyword">int</span> len,<span class="hljs-keyword">int</span> seed)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">img</strong> </td><td style="text-align:left"> Image to display inside the header on the left of the label </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Initial tree state value out of nk_collapse_states </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">hash</strong> </td><td style="text-align:left"> Memory block or string to generate the ID from </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">len</strong> </td><td style="text-align:left"> Size of passed memory block or string in <strong class="underscore">hash</strong> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">seed</strong> </td><td style="text-align:left"> Seeding value if this function is called in a loop or default to <code>0</code> </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_pop">&nbsp;</a><a class="target" name="toc1.7.7.10">&nbsp;</a><h4>nk_tree_pop</h4>
<p>

Ends a collapsabale UI section
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_tree_pop</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling <code>nk_tree_xxx_push_xxx</code> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_tree_state_push">&nbsp;</a><a class="target" name="toc1.7.7.11">&nbsp;</a><h4>nk_tree_state_push</h4>
<p>

Start a collapsable UI section with external state management
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_tree_state_push</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">enum</span> nk_tree_type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, <span class="hljs-keyword">enum</span> nk_collapse_states *state)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling <code>nk_tree_xxx_push_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Persistent state to update </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_state_image_push">&nbsp;</a><a class="target" name="toc1.7.7.12">&nbsp;</a><h4>nk_tree_state_image_push</h4>
<p>

Start a collapsable UI section with image and label header and external state management
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_tree_state_image_push</span><span class="hljs-params">(struct nk_context*, <span class="hljs-keyword">enum</span> nk_tree_type, struct nk_image, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title, <span class="hljs-keyword">enum</span> nk_collapse_states *state)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling <code>nk_tree_xxx_push_xxx</code> </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">img</strong> </td><td style="text-align:left"> Image to display inside the header on the left of the label </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">type</strong> </td><td style="text-align:left"> Value from the <a href="#nk_tree_type">nk_tree_type</a> section to visually mark a tree node header as either a collapseable UI section or tree node </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">title</strong> </td><td style="text-align:left"> Label printed in the tree header </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">state</strong> </td><td style="text-align:left"> Persistent state to update </td></tr>
</tbody></table></div>
Returns <code>true(1)</code> if visible and fillable with widgets or <code>false(0)</code> otherwise

<p></p>
<a class="target" name="nk_tree_state_pop">&nbsp;</a><a class="target" name="toc1.7.7.13">&nbsp;</a><h4>nk_tree_state_pop</h4>
<p>

Ends a collapsabale UI section
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_tree_state_pop</span><span class="hljs-params">(struct nk_context*)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling <code>nk_tree_xxx_push_xxx</code> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="properties">&nbsp;</a><a class="target" name="toc1.7.8">&nbsp;</a><h3>Properties</h3>
<p>

Properties are the main value modification widgets in Nuklear. Changing a value
can be achieved by dragging, adding/removing incremental steps on button click
or by directly typing a number.

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="toc1.7.8.1">&nbsp;</a><h4>Usage</h4>
<p>

Each property requires a unique name for identifaction that is also used for
displaying a label. If you want to use the same name multiple times make sure
add a '#' before your name. The '#' will not be shown but will generate a
unique ID. Each propery also takes in a minimum and maximum value. If you want
to make use of the complete number range of a type just use the provided
type limits from <code>limits.h</code>. For example <code>INT_MIN</code> and <code>INT_MAX</code> for
<code>nk_property_int</code> and <code>nk_propertyi</code>. In additional each property takes in
a increment value that will be added or subtracted if either the increment
decrement button is clicked. Finally there is a value for increment per pixel
dragged that is added or subtracted from the value.
</p><pre class="listing tilde"><code><span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nk_context</span> <span class="hljs-title">ctx</span>;</span>
nk_init_xxx(&amp;ctx, ...);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// Input</span>
    Event evt;
    nk_input_begin(&amp;ctx);
    <span class="hljs-keyword">while</span> (GetEvent(&amp;evt)) {
        <span class="hljs-keyword">if</span> (evt.type == MOUSE_MOVE)
            nk_input_motion(&amp;ctx, evt.motion.x, evt.motion.y);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evt.type == [...]) {
            nk_input_xxx(...);
        }
    }
    nk_input_end(&amp;ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Window</span>
    <span class="hljs-keyword">if</span> (nk_begin_xxx(...) {
        <span class="hljs-comment">// Property</span>
        nk_layout_row_dynamic(...);
        nk_property_int(ctx, <span class="hljs-string">"ID"</span>, INT_MIN, &amp;value, INT_MAX, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    }
    nk_end(ctx);
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Draw</span>
    <span class="hljs-keyword">const</span> struct nk_command *cmd = <span class="hljs-number">0</span>;
    nk_foreach(cmd, &amp;ctx) {
    <span class="hljs-keyword">switch</span> (cmd-&gt;type) {
    <span class="hljs-keyword">case</span> NK_COMMAND_LINE:
        your_draw_line_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> NK_COMMAND_RECT
        your_draw_rect_function(...)
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> ...:
        <span class="hljs-comment">// [...]</span>
    }
}
nk_free(&amp;ctx);</code></pre>
<a class="target" name="reference">&nbsp;</a><a class="target" name="toc1.7.8.2">&nbsp;</a><h4>Reference</h4>
<p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Function </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> nk_property_int </td><td style="text-align:left"> Integer property directly modifing a passed in value </td></tr>
<tr><td style="text-align:left"> nk_property_float </td><td style="text-align:left"> Float property directly modifing a passed in value </td></tr>
<tr><td style="text-align:left"> nk_property_double </td><td style="text-align:left"> Double property directly modifing a passed in value </td></tr>
<tr><td style="text-align:left"> nk_propertyi </td><td style="text-align:left"> Integer property returning the modified int value </td></tr>
<tr><td style="text-align:left"> nk_propertyf </td><td style="text-align:left"> Float property returning the modified float value </td></tr>
<tr><td style="text-align:left"> nk_propertyd </td><td style="text-align:left"> Double property returning the modified double value </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_property_int">&nbsp;</a><a class="target" name="toc1.7.8.3">&nbsp;</a><h4>nk_property_int</h4>
<p>

Integer property directly modifing a passed in value

</p><p>

</p><div class="admonition warning">To generate a unique property ID using the same label make sure to insert
    a <code>#</code> at the beginning. It will not be shown but guarantees correct behavior.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_property_int</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> *val, <span class="hljs-keyword">int</span> max, <span class="hljs-keyword">int</span> step, <span class="hljs-keyword">float</span> inc_per_pixel)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling a layouting function </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> String used both as a label as well as a unique identifier </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">min</strong> </td><td style="text-align:left"> Minimum value not allowed to be underflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">val</strong> </td><td style="text-align:left"> Integer pointer to be modified </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">max</strong> </td><td style="text-align:left"> Maximum value not allowed to be overflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">step</strong> </td><td style="text-align:left"> Increment added and subtracted on increment and decrement button </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">inc_per_pixel</strong> </td><td style="text-align:left"> Value per pixel added or subtracted on dragging </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_property_float">&nbsp;</a><a class="target" name="toc1.7.8.4">&nbsp;</a><h4>nk_property_float</h4>
<p>

Float property directly modifing a passed in value

</p><p>

</p><div class="admonition warning">To generate a unique property ID using the same label make sure to insert
    a <code>#</code> at the beginning. It will not be shown but guarantees correct behavior.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_property_float</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> *val, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> step, <span class="hljs-keyword">float</span> inc_per_pixel)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling a layouting function </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> String used both as a label as well as a unique identifier </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">min</strong> </td><td style="text-align:left"> Minimum value not allowed to be underflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">val</strong> </td><td style="text-align:left"> Float pointer to be modified </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">max</strong> </td><td style="text-align:left"> Maximum value not allowed to be overflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">step</strong> </td><td style="text-align:left"> Increment added and subtracted on increment and decrement button </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">inc_per_pixel</strong> </td><td style="text-align:left"> Value per pixel added or subtracted on dragging </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_property_double">&nbsp;</a><a class="target" name="toc1.7.8.5">&nbsp;</a><h4>nk_property_double</h4>
<p>

Double property directly modifing a passed in value

</p><p>

</p><div class="admonition warning">To generate a unique property ID using the same label make sure to insert
    a <code>#</code> at the beginning. It will not be shown but guarantees correct behavior.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nk_property_double</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">double</span> min, <span class="hljs-keyword">double</span> *val, <span class="hljs-keyword">double</span> max, <span class="hljs-keyword">double</span> step, <span class="hljs-keyword">double</span> inc_per_pixel)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling a layouting function </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> String used both as a label as well as a unique identifier </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">min</strong> </td><td style="text-align:left"> Minimum value not allowed to be underflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">val</strong> </td><td style="text-align:left"> Double pointer to be modified </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">max</strong> </td><td style="text-align:left"> Maximum value not allowed to be overflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">step</strong> </td><td style="text-align:left"> Increment added and subtracted on increment and decrement button </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">inc_per_pixel</strong> </td><td style="text-align:left"> Value per pixel added or subtracted on dragging </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="nk_propertyi">&nbsp;</a><a class="target" name="toc1.7.8.6">&nbsp;</a><h4>nk_propertyi</h4>
<p>

Integer property modifing a passed in value and returning the new value

</p><p>

</p><div class="admonition warning">To generate a unique property ID using the same label make sure to insert
    a <code>#</code> at the beginning. It will not be shown but guarantees correct behavior.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nk_propertyi</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> max, <span class="hljs-keyword">int</span> step, <span class="hljs-keyword">float</span> inc_per_pixel)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling a layouting function </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> String used both as a label as well as a unique identifier </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">min</strong> </td><td style="text-align:left"> Minimum value not allowed to be underflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">val</strong> </td><td style="text-align:left"> Current integer value to be modified and returned </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">max</strong> </td><td style="text-align:left"> Maximum value not allowed to be overflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">step</strong> </td><td style="text-align:left"> Increment added and subtracted on increment and decrement button </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">inc_per_pixel</strong> </td><td style="text-align:left"> Value per pixel added or subtracted on dragging </td></tr>
</tbody></table></div>
Returns the new modified integer value

<p></p>
<a class="target" name="nk_propertyf">&nbsp;</a><a class="target" name="toc1.7.8.7">&nbsp;</a><h4>nk_propertyf</h4>
<p>

Float property modifing a passed in value and returning the new value

</p><p>

</p><div class="admonition warning">To generate a unique property ID using the same label make sure to insert
    a <code>#</code> at the beginning. It will not be shown but guarantees correct behavior.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">nk_propertyf</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> val, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> step, <span class="hljs-keyword">float</span> inc_per_pixel)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling a layouting function </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> String used both as a label as well as a unique identifier </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">min</strong> </td><td style="text-align:left"> Minimum value not allowed to be underflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">val</strong> </td><td style="text-align:left"> Current float value to be modified and returned </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">max</strong> </td><td style="text-align:left"> Maximum value not allowed to be overflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">step</strong> </td><td style="text-align:left"> Increment added and subtracted on increment and decrement button </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">inc_per_pixel</strong> </td><td style="text-align:left"> Value per pixel added or subtracted on dragging </td></tr>
</tbody></table></div>
Returns the new modified float value

<p></p>
<a class="target" name="nk_propertyd">&nbsp;</a><a class="target" name="toc1.7.8.8">&nbsp;</a><h4>nk_propertyd</h4>
<p>

Float property modifing a passed in value and returning the new value

</p><p>

</p><div class="admonition warning">To generate a unique property ID using the same label make sure to insert
    a <code>#</code> at the beginning. It will not be shown but guarantees correct behavior.</div>

<p></p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">nk_propertyd</span><span class="hljs-params">(struct nk_context *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">double</span> min, <span class="hljs-keyword">double</span> val, <span class="hljs-keyword">double</span> max, <span class="hljs-keyword">double</span> step, <span class="hljs-keyword">double</span> inc_per_pixel)</span></span>;</code></pre><p></p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Parameter </th><th style="text-align:left"> Description </th></tr>
<tr><td style="text-align:left"> <strong class="underscore">ctx</strong> </td><td style="text-align:left"> Must point to an previously initialized <code>nk_context</code> struct after calling a layouting function </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">name</strong> </td><td style="text-align:left"> String used both as a label as well as a unique identifier </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">min</strong> </td><td style="text-align:left"> Minimum value not allowed to be underflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">val</strong> </td><td style="text-align:left"> Current double value to be modified and returned </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">max</strong> </td><td style="text-align:left"> Maximum value not allowed to be overflown </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">step</strong> </td><td style="text-align:left"> Increment added and subtracted on increment and decrement button </td></tr>
<tr><td style="text-align:left"> <strong class="underscore">inc_per_pixel</strong> </td><td style="text-align:left"> Value per pixel added or subtracted on dragging </td></tr>
</tbody></table></div>
Returns the new modified double value
        -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X”
X...XXXXXXXXXXXXX...X -           "

<p></p>
<a class="target" name="license">&nbsp;</a><a class="target" name="toc1.8">&nbsp;</a><h2>License</h2>
<pre class="listing tilde"><code>   ------------------------------------------------------------------------------
   This software is available under 2 licenses -- choose whichever you prefer.
   ------------------------------------------------------------------------------
   ALTERNATIVE A - MIT License
   Copyright (c) 2016-2018 Micha Mettke
   Permission is hereby granted, free of charge, to any person obtaining a copy of
   this software and associated documentation files (the "Software"), to deal in
   the Software without restriction, including without limitation the rights to
   use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is furnished to do
   so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
   ------------------------------------------------------------------------------
   ALTERNATIVE B - Public Domain (www.unlicense.org)
   This is free and unencumbered software released into the public domain.
   Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
   software, either in source code form or as a compiled binary, for any purpose,
   commercial or non-commercial, and by any means.
   In jurisdictions that recognize copyright laws, the author or authors of this
   software dedicate any and all copyright interest in the software to the public
   domain. We make this dedication for the benefit of the public at large and to
   the detriment of our heirs and successors. We intend this dedication to be an
   overt act of relinquishment in perpetuity of all present and future rights to
   this software under copyright law.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   ------------------------------------------------------------------------------</code></pre>
<a class="target" name="changelog">&nbsp;</a><a class="target" name="toc1.9">&nbsp;</a><h2>Changelog</h2>
<pre class="listing tilde"><code>[date][x.yy.zz]-[description]
-[date]: date on which the change has been pushed
-[x.yy.zz]: Numerical version string representation. Each version number on the right
            resets back to zero if version on the left is incremented.
   - [x]: Major version with API and library breaking changes
   - [yy]: Minor version with non-breaking API and library changes
   - [zz]: Bug fix version with no direct changes to API
- 2018/04/01 (4.00.1) - Fixed calling `nk_convert` multiple time per single frame
- 2018/04/01 (4.00.0) - BREAKING CHANGE: nk_draw_list_clear no longer tries to
                        clear provided buffers. So make sure to either free
                        or clear each passed buffer after calling nk_convert.
- 2018/02/23 (3.00.6) - Fixed slider dragging behavior
- 2018/01/31 (3.00.5) - Fixed overcalculation of cursor data in font baking process
- 2018/01/31 (3.00.4) - Removed name collision with stb_truetype
- 2018/01/28 (3.00.3) - Fixed panel window border drawing bug
- 2018/01/12 (3.00.2) - Added `nk_group_begin_titled` for separed group identifier and title
- 2018/01/07 (3.00.1) - Started to change documentation style
- 2018/01/05 (3.00.0) - BREAKING CHANGE: The previous color picker API was broken
                       because of conversions between float and byte color representation.
                       Color pickers now use floating point values to represent
                       HSV values. To get back the old behavior I added some additional
                       color conversion functions to cast between nk_color and
                       nk_colorf.
- 2017/12/23 (2.00.7) - Fixed small warning
- 2017/12/23 (2.00.7) - Fixed nk_edit_buffer behavior if activated to allow input
- 2017/12/23 (2.00.7) - Fixed modifyable progressbar dragging visuals and input behavior
- 2017/12/04 (2.00.6) - Added formated string tooltip widget
- 2017/11/18 (2.00.5) - Fixed window becoming hidden with flag NK_WINDOW_NO_INPUT
- 2017/11/15 (2.00.4) - Fixed font merging
- 2017/11/07 (2.00.3) - Fixed window size and position modifier functions
- 2017/09/14 (2.00.2) - Fixed nk_edit_buffer and nk_edit_focus behavior
- 2017/09/14 (2.00.1) - Fixed window closing behavior
- 2017/09/14 (2.00.0) - BREAKING CHANGE: Modifing window position and size funtions now
                       require the name of the window and must happen outside the window
                       building process (between function call nk_begin and nk_end).
- 2017/09/11 (1.40.9) - Fixed window background flag if background window is declared last
- 2017/08/27 (1.40.8) - Fixed `nk_item_is_any_active` for hidden windows
- 2017/08/27 (1.40.7) - Fixed window background flag
- 2017/07/07 (1.40.6) - Fixed missing clipping rect check for hovering/clicked
                       query for widgets
- 2017/07/07 (1.40.5) - Fixed drawing bug for vertex output for lines and stroked
                       and filled rectangles
- 2017/07/07 (1.40.4) - Fixed bug in nk_convert trying to add windows that are in
                       process of being destroyed.
- 2017/07/07 (1.40.3) - Fixed table internal bug caused by storing table size in
                       window instead of directly in table.
- 2017/06/30 (1.40.2) - Removed unneeded semicolon in C++ NK_ALIGNOF macro
- 2017/06/30 (1.40.1) - Fixed drawing lines smaller or equal zero
- 2017/06/08 (1.40.0) - Removed the breaking part of last commit. Auto layout now only
                       comes in effect if you pass in zero was row height argument
- 2017/06/08 (1.40.0) - BREAKING CHANGE: while not directly API breaking it will change
                       how layouting works. From now there will be an internal minimum
                       row height derived from font height. If you need a row smaller than
                       that you can directly set it by `nk_layout_set_min_row_height` and
                       reset the value back by calling `nk_layout_reset_min_row_height.
- 2017/06/08 (1.39.1) - Fixed property text edit handling bug caused by past `nk_widget` fix
- 2017/06/08 (1.39.0) - Added function to retrieve window space without calling a nk_layout_xxx function
- 2017/06/06 (1.38.5) - Fixed `nk_convert` return flag for command buffer
- 2017/05/23 (1.38.4) - Fixed activation behavior for widgets partially clipped
- 2017/05/10 (1.38.3) - Fixed wrong min window size mouse scaling over boundries
- 2017/05/09 (1.38.2) - Fixed vertical scrollbar drawing with not enough space
- 2017/05/09 (1.38.1) - Fixed scaler dragging behavior if window size hits minimum size
- 2017/05/06 (1.38.0) - Added platform double-click support
- 2017/04/20 (1.37.1) - Fixed key repeat found inside glfw demo backends
- 2017/04/20 (1.37.0) - Extended properties with selection and clipbard support
- 2017/04/20 (1.36.2) - Fixed #405 overlapping rows with zero padding and spacing
- 2017/04/09 (1.36.1) - Fixed #403 with another widget float error
- 2017/04/09 (1.36.0) - Added window `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NOT_INTERACTIVE` flags
- 2017/04/09 (1.35.3) - Fixed buffer heap corruption
- 2017/03/25 (1.35.2) - Fixed popup overlapping for `NK_WINDOW_BACKGROUND` windows
- 2017/03/25 (1.35.1) - Fixed windows closing behavior
- 2017/03/18 (1.35.0) - Added horizontal scroll requested in #377
- 2017/03/18 (1.34.3) - Fixed long window header titles
- 2017/03/04 (1.34.2) - Fixed text edit filtering
- 2017/03/04 (1.34.1) - Fixed group closable flag
- 2017/02/25 (1.34.0) - Added custom draw command for better language binding support
- 2017/01/24 (1.33.0) - Added programatic way of remove edit focus
- 2017/01/24 (1.32.3) - Fixed wrong define for basic type definitions for windows
- 2017/01/21 (1.32.2) - Fixed input capture from hidden or closed windows
- 2017/01/21 (1.32.1) - Fixed slider behavior and drawing
- 2017/01/13 (1.32.0) - Added flag to put scaler into the bottom left corner
- 2017/01/13 (1.31.0) - Added additional row layouting method to combine both
                       dynamic and static widgets.
- 2016/12/31 (1.30.0) - Extended scrollbar offset from 16-bit to 32-bit
- 2016/12/31 (1.29.2)- Fixed closing window bug of minimized windows
- 2016/12/03 (1.29.1)- Fixed wrapped text with no seperator and C89 error
- 2016/12/03 (1.29.0) - Changed text wrapping to process words not characters
- 2016/11/22 (1.28.6)- Fixed window minimized closing bug
- 2016/11/19 (1.28.5)- Fixed abstract combo box closing behavior
- 2016/11/19 (1.28.4)- Fixed tooltip flickering
- 2016/11/19 (1.28.3)- Fixed memory leak caused by popup repeated closing
- 2016/11/18 (1.28.2)- Fixed memory leak caused by popup panel allocation
- 2016/11/10 (1.28.1)- Fixed some warnings and C++ error
- 2016/11/10 (1.28.0)- Added additional `nk_button` versions which allows to directly
                       pass in a style struct to change buttons visual.
- 2016/11/10 (1.27.0)- Added additional 'nk_tree' versions to support external state
                       storage. Just like last the `nk_group` commit the main
                       advantage is that you optionally can minimize nuklears runtime
                       memory consumption or handle hash collisions.
- 2016/11/09 (1.26.0)- Added additional `nk_group` version to support external scrollbar
                       offset storage. Main advantage is that you can externalize
                       the memory management for the offset. It could also be helpful
                       if you have a hash collision in `nk_group_begin` but really
                       want the name. In addition I added `nk_list_view` which allows
                       to draw big lists inside a group without actually having to
                       commit the whole list to nuklear (issue #269).
- 2016/10/30 (1.25.1)- Fixed clipping rectangle bug inside `nk_draw_list`
- 2016/10/29 (1.25.0)- Pulled `nk_panel` memory management into nuklear and out of
                       the hands of the user. From now on users don't have to care
                       about panels unless they care about some information. If you
                       still need the panel just call `nk_window_get_panel`.
- 2016/10/21 (1.24.0)- Changed widget border drawing to stroked rectangle from filled
                       rectangle for less overdraw and widget background transparency.
- 2016/10/18 (1.23.0)- Added `nk_edit_focus` for manually edit widget focus control
- 2016/09/29 (1.22.7)- Fixed deduction of basic type in non `&lt;stdint.h&gt;` compilation
- 2016/09/29 (1.22.6)- Fixed edit widget UTF-8 text cursor drawing bug
- 2016/09/28 (1.22.5)- Fixed edit widget UTF-8 text appending/inserting/removing
- 2016/09/28 (1.22.4)- Fixed drawing bug inside edit widgets which offset all text
                       text in every edit widget if one of them is scrolled.
- 2016/09/28 (1.22.3)- Fixed small bug in edit widgets if not active. The wrong
                       text length is passed. It should have been in bytes but
                       was passed as glyphes.
- 2016/09/20 (1.22.2)- Fixed color button size calculation
- 2016/09/20 (1.22.1)- Fixed some `nk_vsnprintf` behavior bugs and removed
                       `&lt;stdio.h&gt;` again from `NK_INCLUDE_STANDARD_VARARGS`.
- 2016/09/18 (1.22.0)- C89 does not support vsnprintf only C99 and newer as well
                       as C++11 and newer. In addition to use vsnprintf you have
                       to include &lt;stdio.h&gt;. So just defining `NK_INCLUDE_STD_VAR_ARGS`
                       is not enough. That behavior is now fixed. By default if
                       both varargs as well as stdio is selected I try to use
                       vsnprintf if not possible I will revert to vsprintf. If
                       varargs but not stdio was defined I will use my own function.
- 2016/09/15 (1.21.2)- Fixed panel `close` behavior for deeper panel levels
- 2016/09/15 (1.21.1)- Fixed C++ errors and wrong argument to `nk_panel_get_xxxx`
- 2016/09/13 (1.21.0) - !BREAKING! Fixed nonblocking popup behavior in menu, combo,
                       and contextual which prevented closing in y-direction if
                       popup did not reach max height.
                       In addition the height parameter was changed into vec2
                       for width and height to have more control over the popup size.
- 2016/09/13 (1.20.3) - Cleaned up and extended type selection
- 2016/09/13 (1.20.2)- Fixed slider behavior hopefully for the last time. This time
                       all calculation are correct so no more hackery.
- 2016/09/13 (1.20.1)- Internal change to divide window/panel flags into panel flags and types.
                       Suprisinly spend years in C and still happened to confuse types
                       with flags. Probably something to take note.
- 2016/09/08 (1.20.0)- Added additional helper function to make it easier to just
                       take the produced buffers from `nk_convert` and unplug the
                       iteration process from `nk_context`. So now you can
                       just use the vertex,element and command buffer + two pointer
                       inside the command buffer retrieved by calls `nk__draw_begin`
                       and `nk__draw_end` and macro `nk_draw_foreach_bounded`.
- 2016/09/08 (1.19.0)- Added additional asserts to make sure every `nk_xxx_begin` call
                       for windows, popups, combobox, menu and contextual is guarded by
                       `if` condition and does not produce false drawing output.
- 2016/09/08 (1.18.0)- Changed confusing name for `NK_SYMBOL_RECT_FILLED`, `NK_SYMBOL_RECT`
                       to hopefully easier to understand `NK_SYMBOL_RECT_FILLED` and
                       `NK_SYMBOL_RECT_OUTLINE`.
- 2016/09/08 (1.17.0)- Changed confusing name for `NK_SYMBOL_CIRLCE_FILLED`, `NK_SYMBOL_CIRCLE`
                       to hopefully easier to understand `NK_SYMBOL_CIRCLE_FILLED` and
                       `NK_SYMBOL_CIRCLE_OUTLINE`.
- 2016/09/08 (1.16.0)- Added additional checks to select correct types if `NK_INCLUDE_FIXED_TYPES`
                       is not defined by supporting the biggest compiler GCC, clang and MSVC.
- 2016/09/07 (1.15.3)- Fixed `NK_INCLUDE_COMMAND_USERDATA` define to not cause an error
- 2016/09/04 (1.15.2)- Fixed wrong combobox height calculation
- 2016/09/03 (1.15.1)- Fixed gaps inside combo boxes in OpenGL
- 2016/09/02 (1.15.0) - Changed nuklear to not have any default vertex layout and
                       instead made it user provided. The range of types to convert
                       to is quite limited at the moment, but I would be more than
                       happy to accept PRs to add additional.
- 2016/08/30 (1.14.2) - Removed unused variables
- 2016/08/30 (1.14.1) - Fixed C++ build errors
- 2016/08/30 (1.14.0) - Removed mouse dragging from SDL demo since it does not work correctly
- 2016/08/30 (1.13.4) - Tweaked some default styling variables
- 2016/08/30 (1.13.3) - Hopefully fixed drawing bug in slider, in general I would
                       refrain from using slider with a big number of steps.
- 2016/08/30 (1.13.2) - Fixed close and minimize button which would fire even if the
                       window was in Read Only Mode.
- 2016/08/30 (1.13.1) - Fixed popup panel padding handling which was previously just
                       a hack for combo box and menu.
- 2016/08/30 (1.13.0) - Removed `NK_WINDOW_DYNAMIC` flag from public API since
                       it is bugged and causes issues in window selection.
- 2016/08/30 (1.12.0) - Removed scaler size. The size of the scaler is now
                       determined by the scrollbar size
- 2016/08/30 (1.11.2) - Fixed some drawing bugs caused by changes from 1.11
- 2016/08/30 (1.11.1) - Fixed overlapping minimized window selection
- 2016/08/30 (1.11.0) - Removed some internal complexity and overly complex code
                       handling panel padding and panel border.
- 2016/08/29 (1.10.0) - Added additional height parameter to `nk_combobox_xxx`
- 2016/08/29 (1.10.0) - Fixed drawing bug in dynamic popups
- 2016/08/29 (1.10.0) - Added experimental mouse scrolling to popups, menus and comboboxes
- 2016/08/26 (1.10.0) - Added window name string prepresentation to account for
                       hash collisions. Currently limited to NK_WINDOW_MAX_NAME
                       which in term can be redefined if not big enough.
- 2016/08/26 (1.10.0) - Added stacks for temporary style/UI changes in code
- 2016/08/25 (1.10.0) - Changed `nk_input_is_key_pressed` and 'nk_input_is_key_released'
                       to account for key press and release happening in one frame.
- 2016/08/25 (1.10.0) - Added additional nk_edit flag to directly jump to the end on activate
- 2016/08/17 (1.09.6)- Removed invalid check for value zero in nk_propertyx
- 2016/08/16 (1.09.5)- Fixed ROM mode for deeper levels of popup windows parents.
- 2016/08/15 (1.09.4)- Editbox are now still active if enter was pressed with flag
                       `NK_EDIT_SIG_ENTER`. Main reasoning is to be able to keep
                       typing after commiting.
- 2016/08/15 (1.09.4)- Removed redundant code
- 2016/08/15 (1.09.4)- Fixed negative numbers in `nk_strtoi` and remove unused variable
- 2016/08/15 (1.09.3)- Fixed `NK_WINDOW_BACKGROUND` flag behavior to select a background
                       window only as selected by hovering and not by clicking.
- 2016/08/14 (1.09.2)- Fixed a bug in font atlas which caused wrong loading
                       of glyphes for font with multiple ranges.
- 2016/08/12 (1.09.1)- Added additional function to check if window is currently
                       hidden and therefore not visible.
- 2016/08/12 (1.09.1)- nk_window_is_closed now queries the correct flag `NK_WINDOW_CLOSED`
                       instead of the old flag `NK_WINDOW_HIDDEN`
- 2016/08/09 (1.09.0) - Added additional double version to nk_property and changed
                       the underlying implementation to not cast to float and instead
                       work directly on the given values.
- 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
                       floating pointer number to string conversion for additional
                       precision.
- 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
                       string to floating point number conversion for additional
                       precision.
- 2016/08/08 (1.07.2)- Fixed compiling error without define NK_INCLUDE_FIXED_TYPE
- 2016/08/08 (1.07.1)- Fixed possible floating point error inside `nk_widget` leading
                       to wrong wiget width calculation which results in widgets falsly
                       becomming tagged as not inside window and cannot be accessed.
- 2016/08/08 (1.07.0) - Nuklear now differentiates between hiding a window (NK_WINDOW_HIDDEN) and
                       closing a window (NK_WINDOW_CLOSED). A window can be hidden/shown
                       by using `nk_window_show` and closed by either clicking the close
                       icon in a window or by calling `nk_window_close`. Only closed
                       windows get removed at the end of the frame while hidden windows
                       remain.
- 2016/08/08 (1.06.0) - Added `nk_edit_string_zero_terminated` as a second option to
                       `nk_edit_string` which takes, edits and outputs a '\0' terminated string.
- 2016/08/08 (1.05.4)- Fixed scrollbar auto hiding behavior
- 2016/08/08 (1.05.3)- Fixed wrong panel padding selection in `nk_layout_widget_space`
- 2016/08/07 (1.05.2)- Fixed old bug in dynamic immediate mode layout API, calculating
                       wrong item spacing and panel width.
                       define NK_INCLUDE_STANDARD_VARARGS to allow more fine
                       grained controlled over library includes.
- 2016/08/06 (1.04.5)- Changed memset calls to NK_MEMSET
- 2016/08/04 (1.04.4)- Fixed fast window scaling behavior
- 2016/08/04 (1.04.3)- Fixed window scaling, movement bug which appears if you
                       move/scale a window and another window is behind it.
                       If you are fast enough then the window behind gets activated
                       and the operation is blocked. I now require activating
                       by hovering only if mouse is not pressed.
- 2016/08/04 (1.04.2)- Fixed changing fonts
- 2016/08/03 (1.04.1)- Fixed `NK_WINDOW_BACKGROUND` behavior
- 2016/08/03 (1.04.0) - Added color parameter to `nk_draw_image`
- 2016/08/03 (1.04.0) - Added additional window padding style attributes for
                       sub windows (combo, menu, ...)
- 2016/08/03 (1.04.0) - Added functions to show/hide software cursor
- 2016/08/03 (1.04.0) - Added `NK_WINDOW_BACKGROUND` flag to force a window
                       to be always in the background of the screen
- 2016/08/03 (1.03.2)- Removed invalid assert macro for NK_RGB color picker
- 2016/08/01 (1.03.1)- Added helper macros into header include guard
- 2016/07/29 (1.03.0) - Moved the window/table pool into the header part to
                       simplify memory management by removing the need to
                       allocate the pool.
- 2016/07/29 (1.02.0) - Added auto scrollbar hiding window flag which if enabled
                       will hide the window scrollbar after NK_SCROLLBAR_HIDING_TIMEOUT
                       seconds without window interaction. To make it work
                       you have to also set a delta time inside the `nk_context`.
- 2016/07/25 (1.01.1) - Fixed small panel and panel border drawing bugs
- 2016/07/15 (1.01.0) - Added software cursor to `nk_style` and `nk_context`
- 2016/07/15 (1.01.0) - Added const correctness to `nk_buffer_push' data argument
- 2016/07/15 (1.01.0) - Removed internal font baking API and simplified
                       font atlas memory management by converting pointer
                       arrays for fonts and font configurations to lists.
- 2016/07/15 (1.00.0) - Changed button API to use context dependend button
                       behavior instead of passing it for every function call.</code></pre>
<a class="target" name="gallery">&nbsp;</a><a class="target" name="toc1.10">&nbsp;</a><h2>Gallery</h2>
<p>

</p><div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/13538240/acd96876-e249-11e5-9547-5ac0b19667a0.png" target="_blank"><img class="markdeep" src="nuklear_files/acd96876-e249-11e5-9547-5ac0b19667a0.png"></a><div class="imagecaption"><a class="target" name="figure_blue">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> Feature overview with blue color styling</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/13538243/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png" target="_blank"><img class="markdeep" src="nuklear_files/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png"></a><div class="imagecaption"><a class="target" name="figure_red">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;2:</b> Feature overview with red color styling</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/11282359/3325e3c6-8eff-11e5-86cb-cf02b0596087.png" target="_blank"><img class="markdeep" src="nuklear_files/3325e3c6-8eff-11e5-86cb-cf02b0596087.png"></a><div class="imagecaption"><a class="target" name="figure_widgets">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;3:</b> Widget overview</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/11033668/59ab5d04-86e5-11e5-8091-c56f16411565.png" target="_blank"><img class="markdeep" src="nuklear_files/59ab5d04-86e5-11e5-8091-c56f16411565.png"></a><div class="imagecaption"><a class="target" name="figure_blackwhite">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;4:</b> Black and white</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/10718115/02a9ba08-7b6b-11e5-950f-adacdd637739.png" target="_blank"><img class="markdeep" src="nuklear_files/02a9ba08-7b6b-11e5-950f-adacdd637739.png"></a><div class="imagecaption"><a class="target" name="figure_filexp">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;5:</b> File explorer</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/12779619/2a20d72c-ca69-11e5-95fe-4edecf820d5c.png" target="_blank"><img class="markdeep" src="nuklear_files/2a20d72c-ca69-11e5-95fe-4edecf820d5c.png"></a><div class="imagecaption"><a class="target" name="figure_opengl">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;6:</b> OpenGL Editor</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/9976995/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif" target="_blank"><img class="markdeep" src="nuklear_files/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif"></a><div class="imagecaption"><a class="target" name="figure_nodedit">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;7:</b> Node Editor</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/15991632/76494854-30b8-11e6-9555-a69840d0d50b.png" target="_blank"><img class="markdeep" src="nuklear_files/76494854-30b8-11e6-9555-a69840d0d50b.png"></a><div class="imagecaption"><a class="target" name="figure_skinning">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;8:</b> Using skinning in Nuklear</div></div>
<div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="https://cloud.githubusercontent.com/assets/8057201/14902576/339926a8-0d9c-11e6-9fee-a8b73af04473.png" target="_blank"><img class="markdeep" src="nuklear_files/339926a8-0d9c-11e6-9fee-a8b73af04473.png"></a><div class="imagecaption"><a class="target" name="figure_bf">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;9:</b> Heavy modified version</div></div>

<p></p>
<a class="target" name="credits">&nbsp;</a><a class="target" name="toc1.11">&nbsp;</a><h2>Credits</h2>
<p>

Developed by Micha Mettke and every direct or indirect github contributor. <br><br>
Embeds <a href="https://github.com/nothings/stb/blob/master/stb_textedit.h">stb_texedit</a>, <a href="https://github.com/nothings/stb/blob/master/stb_truetype.h">stb_truetype</a> and <a href="https://github.com/nothings/stb/blob/master/stb_rect_pack.h">stb_rectpack</a> by Sean Barret (public domain) <br>
Uses <a href="https://github.com/r-lyeh/stddoc.c">stddoc.c</a> from <a href="mailto:r-lyeh@github.com">r-lyeh@github.com</a> for documentation generation <br><br>
Embeds ProggyClean.ttf font by Tristan Grimmer (MIT license). <br>
Big thank you to Omar Cornut (ocornut@github) for his <a href="https://github.com/ocornut/imgui">imgui library</a> and
giving me the inspiration for this library, Casey Muratori for handmade hero
and his original immediate mode graphical user interface idea and Sean
Barret for his amazing single header libraries which restored my faith
in libraries and brought me to create some of my own. Finally Apoorva Joshi
for his single header file packer.
<script>markdeepOptions={tocStyle:'medium'};</script>
<script src="nuklear_files/markdeep.js"></script>
</p></span><div class="markdeepFooter"><i>formatted by <a href="http://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.00&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">✒</div></div></body></html>